/																																									\
	Продолжение математических основнов искуственых интелектов ееееееееееееееееееее

	Автоматов не будет :(
\																																									/

		[Данные и знания]
	Данные - отдельные факты, характеризущие объекты, процессы, явления предметной области и их свойства.
	Знания - закономерности предметной области, полученные в результате практической деятельности и профессионального опыта, позволяющие специалистам ставить и решать задачи в этой области. 

										Знания:
						фактуальные	 операционные

	Программа = Алгоритм + Структура данных   (аналогия с тем что было выше)

	(СБД) = (Программа)--(СУБД)--(БД)         (если выше было все очень строго завязано, то тут уже не совсем)

	(СБЗ) = (БЗ)--(Механизм вывода)--(БД)     (тут еще меньше связано ???)
	.............................................
	... было небольшое лирическое отступление ...
	.............................................
		<Этапы обработки данных>
	D1 - данные как результат наблюдений и измерений
	D2 - обработанные данные в виде таблиц, протоколов, справочников, и т.д.
	D3 - модели(структуры) данных в виде диаграмм, графиков, функций
	D4 - данные на языке описания данных
	D5 - базы данных на машинном носителе информации

		<Этапы обработки знаний>
	Z1 - знания в памяти человека как результат мышления
	Z2 - материальные носители знаний
	Z3 - поле знаний (условное описание основных объектов предметной области, их атрибутов, закономерностей, связей)
	Z4 - знания, описанные на языке представления знаний
	Z5 - базы знаний на машинном носителе информации

		<Особенности знаний>
	1. Внутренняя интерпретируемость
	2. Структурируемость 
	3. Связанность
	4. Семантическая метрика (между понятими может устанавливаться связь близкий/далёкий)
	5. Активность	 (если-то, например в зависимости от достижения предельного значения что-то случается)

		[Prolog]
	. Императивный
	.	Декларативный

	"Страшный" пример программы:
	слияние([], l, l).
	слияние([X|l1], l2, [x|l3]):-
					слияние(l1, l2, l3).

	Формальная система
	(X, A, S, P): X - алфавит системы
								A - набор аксиом
								S - все синтаксически верные конструкции и предложения
								P - правило вывода

		А теперь рассмотрим язык Prolog...


родитель("Михаил","Алексей").
родитель("Евдокия","Алексей").
родитель("Мария","Иоанн").
родитель("Алексей","Иоанн").
родитель("Мария","Софья").
родитель("Алексей","Софья").
родитель("Мария","Феодор").
родитель("Алексей","Феодор").
родитель("Алексей","Петр").
родитель("Наталья","Петр").
родитель("Петр","Анна").
родитель("Екатерина","Анна").
родитель("Петр","Елизавета").
родитель("Екатерина","Елизавета").

мужчина("Михаил").
мужчина("Алексей").
мужчина("Феодор").
мужчина("Петр").
мужчина("Иоанн").

женщина("Евдокия").
женщина("Мария").
женщина("Наталья").
женщина("Софья").
женщина("Анна").
женщина("Екатерина").
женщина("Елизавета").

мать(Кто, Кого):-родитель(Кто, Кого), женщина(Кто).
отец(Кто, Кого):-родитель(Кто, Кого), мужчина(Кто).
сын(Кто, Кого):-родитель(Кого, Кто), мужчина(Кто).
дочь(Кто, Кого):-родитель(Кого, Кто), женщина(Кто).

дед(Прародитель, Потомок):-родитель(Прародитель, Родитель), родитель(Родитель, Потомок), мужчина(Прародитель).
бабушка(Прародитель, Потомок):-родитель(Прародитель, Родитель), родитель(Родитель, Потомок), женщина(Прародитель).
брат(Кто, Кого):-родитель(Взрослый, Кто), родитель(Взрослый, Кого), мужчина(Кто), Кто\==Кого.
сестра(Кто, Кого):-родитель(Взрослый, Кто), родитель(Взрослый, Кого), женщина(Кто), Кто\==Кого.

племянница(Кто, Кого):-родитель(Взрослый, Кого), родитель(Взрослый, ЕёРодитель), брат(Кого, ЕёРодитель), дочь(Кто, ЕёРодитель).
племянница(Кто, Кого):-родитель(Взрослый, Кого), родитель(Взрослый, ЕёРодитель), сестра(Кого, ЕёРодитель), дочь(Кто, ЕёРодитель).

родители(Родитель1, Родитель2):-родитель(Родитель1, Ребенок), родитель(Родитель2, Ребенок), мужчина(Родитель1), Родитель1\==Родитель2.


-----------------------------------------------------
Формальные системы в Prolog
1. Алфавит
	I. 	 Переменные (x, y, z...)
	II.  Константы  (a, b, c...)
	III. Предикатные символы (p, q, r...)
	IV.	 Функциональные символы
	V.   True, false
	VI.  Логические операции V, ^, !, ->
	VII. Кванторы (Any, Exists)
	VIII.Вспомогательные символы

2. Терм
	I. 	 Всякая переменная или константа есть терм
	II.  Пусть t1...tn - некоторые термы, а f - n-местный функциональный символ, тогда f(t1, ..., tn) - тоже терм
	III. Других термов нет

	Если в терме нет переменных, то он называется основным или константным

3. Атомарная/Элементарная/Простая формула
	Если t1...tn термы, а p - предикатный символ, то p(t1,...,tn) атомарная формула

	I. 	 Всякая элементарная/атомарная формула - есть формула 
	II.  Если A и B - формулы, а X - переменная, то:
					!A, A v B, A ^ B, A -> B, Any X A, E X A - формулы
					A - область действия квантора, X - связанная переменная
	III. Других формул нет

4. Литерал
	Либо атомарная формула или её отрицание
	Контрарные литералы -> два одинаковых литерала, положительный и его отрицание

5. Дизъюнкт - дизъюнкция конечного числа литералов

~N - пустой дизъюнкт (под водой (с) Искусственный интеллект)

Говорят, что формула находится в конъюнктивной нормальной форме если она предствляет из себя конъюнкцию конечного числа дизъюнктов

Формула находится в предваренной или префиксной нормальной форме если она имеет вид Q1x1Q2x2...QnxnA
Q1...Qn кванторы
A кванторов не содержит

Говорят, что формула находится в сколеновской нормальной форме если она находится в предваренной нормальной форме и не содержит кванторов существования

-------------
Алгоритм приведения произвольной формулы к множеству дизъюнктов

1. Приведение произвольной формулы к префиксной/нормальной форме
	* 		Замена импликации A->B на эквивалентную ей !A v B
	** 		!(A v B) = !A ^ !B
	** 		!(A ^ B) = !A v !B
	** 		!(Э x) A = Any x !A
	** 		!(Any x) Э x !A
	***		В случае совпадения имен связанных и свободных переменных переименовываем связанную переменную (и в самом кванторе)
	*** 	QxA(x) v/^ B = Qx(A(x) ^/v B)
	****  Any x A(x) ^ Any x B(x) = Any x(A(x) ^ B(x))
	****  Э x A(x) v Э x B(x) = Э x(A(X) v B(X))
	****  Q1xA(x) v/^ Q2yB(y) = Q1XQ2y (A(x)v/^B(y))

2. Приведение формулы к сколеновской нормальной форме

	* Эx Px -> Эа Pa
	Если устраняемый квантор существования самый левый, заменим все вхождения в формулу связанной с ним переменной на (!)новую(!) константу и вычеркнем квантор из префикса формулы 

	** Any x Эy P(x, y)
	y = f(x)  
	Если левее квантора существования имеются кванторы всеобщности, заменим все вхождения в формулу связанной с ним переменной на (!)новый(!) функциональный символ от переменных, связанных стоящими слева кванторами всеобщности

https://swish.swi-prolog.org/p/TivLlOzt.swinb

	Лекция №3

3. Убираем все кванторы всеобщности
4. Используя дистрибутивность, приводим формулу к КНФ
5. Превращаем формулу в множество дизъюнктов

Пример:

Vx (P(x) -> Эy(P(y) V not Q(x, y))) -- раскрываем импликацию
Vx (not P(x) V Эy(P(y) V not Q(x, y))) -- выносим квантор
Vx Эy (not P(x) V P(y) V not Q(x, y)) -- удаляем квантор существования и заменяем 
															связанную с ним переменную на функциональный символ 
Vx (not P(x) V P(f(x)) V not Q(x, f(y))) -- удаляем квантор всеобщности
not P(x) V P(f(x)) V not Q(x, f(y)) -- задача решена

[Подстановки]
th = { x1/t1, ..., xn/tn } -- xi - переменные; ti - термы
1. Все xi различные, i=/=j -> xi =/= xj
2. xi =/= ti
e - пустая подстановка
если в подстановке все термы основные: подстановка называется основной,
	что значит что переменные заменяются на константные выражения 
	(простое выражение это терм или атомарная формула)

Пусть A - простое выражение, th - подстановка, Ath - выражение, 
	которое получается в результате замены в выражении A переменных x1..xn на термы t1..tn соответственно

// Композиция подстаноовок //
Пусть th = { x1/t1, ..., xn/tn }, eta = { y1/s1, ..., ym/sm }

th eta = { x1/t1 eta, ..., xn/tn eta, y1/s1, ..., ym/sm }
если xi = yj, yj/sj выкидываем
если xi = ti eta, xi/ti eta выкинуть

th = { x/f(y), y/z }, eta = { x/a, y/b, z/y }
th eta = { x/f(b), z/y }

Подстановка th называется более общей чем подстановка eta если существует такая подстановка )(, что
th это eta )(
Подстановка th называется унификатором простых выражений A и B, если A th = B th

A = P(f(x), z)
B = P(y, a)
Примеры унификаторов: 
th = { y/fx, z/a } - но этот более общий чем снизу
eta = { x/b, y/fb, z/a } 

Наиболее общий унификатор = наиболее общая подстановка-унификатор

Алгоритмы унификации

Пусть S - конечное множество простых выражений. 
Множество рассогласований d(S) строится так:
а) Зафиксируем самую левую позицию, на которой не во всех выражениях из S находится не один и тот же символ
б) В d(S) заносятся все подвыражения, начинающиеся с этой позиции
---------стоп---------

Пример:
S = { p(f(x), h(y), a), p(f(x), z, a), p(f(x), h(y), b)}
			______ 						______  			 ______
							___ 							_ 						 ____

p(f(x), ) пропускается так как он есть во всех трех
d(S) = { h(y), z }

Ш1. k=0, delta = eps
Ш2. 
- Если 'S delta_k' одноэлементное множество, то delta_k наиболее общий унификатор;
- Иначе строим множество рассогласований d(S delta_k)
Ш3. 
- Если в d(S delta_k) есть переменная x и терм t не содержащий переменную x, тогда
	delta_k+1 = delta_k o { x/t }, k+1 и Ш2;
- Иначе не унифицируемо

Пример:
d(S) = { h(y), z }
{ z / h(y) } = delta_1
S = { p(f(x), h(y), a), p(f(x), h(y), b)}
d(S delta_1) = { a, b } -- согласовать нельзя (только переменную на константу / функцию без этой переменной)

<<<<<< Метод резолюций >>>>>>
Пусть есть два дизъюнкта C1, C2 у которых нет общих переменных

Литерал l1 входит в C1, литерал l2 входит в C2
Если у l1 и l2 есть наиболее общий унификатор, такой что l1th = not l2th,
то тогда (C1 th - l1 th) U (C2 th - l2 th) -- называется резольвентой

X U A, Y U notA -> X U Y

Лекция 06.03
P(X,Y) = X сын Y
Q(X,Y) = X внук Y
P1 = Any(x,z,y) P(X,Y) ^ P(Y,Z) -> Q(x,z) из того что у каждого есть отец следует что у каждого есть внук
P2 = Any(x), E(y) P(x,y) у каждого человека есть отец
G = Any(x)Е(z) Q(x,z) у каждого человека есть внук

Пункт 1)
P1 = Any(x,z,y) -(P(X,Y) ^ P(Y,Z)) v Q(x,z)

Пункт 2)
P1 = Any(x,z,y) -P(X,Y) v -P(Y,Z) v Q(x,z)

Кванторов существования нет. Он в сколеновской нормальной форме
Квантор всеобщности убираем

D1: -P(X,Y) v -P(Y,Z) v Q(x,z)

P2 = Any(x), E(y) P(x,y)

Квантор существования убираем с заменой на функц. символ
P2 = Any(x), P(x,f(x))
D2: P(x,f(x))

Вот так легко разобрать G нельзя ибо P1,P2 => G
Нам нужно перенести G влево
P1,P2,-G => 0

-(Any(x)E(z))
G = E(x)Any(z) -Q(x,z)
G = -Q(a,z)

D1: -P(X,Y) v -P(Y,Z) v Q(x,z)
D2: P(x,f(x))
D3: -Q(a, z)
D3': -Q(a, z') { z' / z, x / a } после этой замены они все станут одинаковыми

Соединяем D1 и D3
D4: -P(a,y) v -P(y, z)
Соединяем D4 с D2 { x / a, y / f(a) }
D5: D2 и D4: P(f(a), z)
Соединяем D2 и D5 { x / f(a), z / f(f(a))}
D6: D2 и D5: 0  Действительно! Если у каждого есть отец, то у каждого есть внук!

Пусть предикат P(x,y,z,s) говорит что: 
в точке x находится обезьяна, в y находится стул или ящик, в z банан
для ситуации s
Предикат R(s) истинный если бананы в обезьяне, иначе ложь
Функция s' = идти(x,y,s) говорит, что обезьяна в ситуации s из точки x переходит в y 
Функция s' = нести(x, y, s)
Функция s' = хватать(s)

1) Надо описать возможности нашей обезьяны
F1 = Any(x, y, z, s) P(x,y,z,s) -> P(u, y, z, идти(x, u, s))
2) Опишем ситуацию со стулом
F2 = Any(x, z, s) P(x, x, z, s) -> P(u, u, z, z, нести(x, u, s))
3) Возможность кусать бананы
F3 = Any(x, s) P(x, x, x, s) -> R(хватать(s))

F4 = P(a, b, c, s0)
G = E(s)R(s)
F1, F2, F3, F4 => G

D1: -P(x,y,z,s) v P(u, y, z, идти(x, u, s))
D2: -P(x,x,z,s) v P(u, y, z, нести(x, u, s))
D3: -P(x,x,x,s) v R(хватать(s))
D4: P(a, b, c, s0)
D5: -R(s) v ANS(s)

D5': D5: -R(s') v ANS(s')
D6 = D5' + D3: { s' / хватать(s) }: -P(x, x, x, s) v ANS(хватать(s))

D6': -P(x', x', x', s') v ANS(хватать(s'))
D7 = D6' и D2: { u / x', z / x', s' / нести(x, x', s) }: -P(x, x, x', s) v ANS(хватать(x, x', s))

D7' = -P(x*, x*, x', s') v ANS(хватать(x*, x', s')))
D8 = D7' и D1: { u / x*, y / x*, x'/z, s'/идти(x, x*, s) }: -P( x, x*, s) v ANS(хватать(x*, z, нести(x, x*, s)))

D9 = D4 и D8: ANS(хватать(b, c, нести(a, b, s0))) -- получили алгоритм для обезьяны

=============
Экспертная система -- программный комплекс, аккумулирующий знания специалистов в конкретных предметных областях и тиражирующие их эмпирический опыт для консультации мнения квалифицированных пользователей

Dendral - химия
Mycin - медицина, анализ заражения крови
Puff
Emycin
Prospector

% Классификации экспертных систем, задачи
1. Интерпретация данных
Процесс определения смысла данных, результаты которого должны быть согласованными и корректными
2. Задача диагностики
Процесс соотнесения объекта с некоторым классом объектов и/или обнаружение неисправностей в некоторой системе
3. Мониторинг
Непрерывная интерпретация данных в режиме реального времени
4. Проектирование
Подготовка спецификации на создание объектов заранее определенными действиями
5. Прогнозирование
Предсказание последствий событий или явлений на основе анализа имеющихся данных
6. Планирование 
Нахождение планов действий по отношению к объектам, которые могут выполнять какие-то функции
7. Обучение
Контроль сложности заданий
8. Управление
Поддержание определенного режима деятельности некоторых объектов
9. Поддержка принятия решений
Совокупность процедур, обеспечивающих лицо, принимающее решения необходимой информацией/рекомендациями, облегчающая процесс принятия решений и контроля их исполнений

Классификация по связи с реальным временем
. статические
. квазидинамические
. динамические

Классификация по поводу интеграции с другими программами
. автономные
. гибридные

Состав экспертных систем

============================ 	===================     ==========
|| 												|| 													||   		||
|| 		База знаний					||  модуль пополнения и 		||   		||
|| 												|| 	корректировки БЗ	----> ||   		||
|| 												|| 													||   		||
|| 												|| 													||   		||
|| 												|| 													||   		||	  o o
============================  ===================     ||   		||   ( ~ )   -- эксперт
						| | 																			||   		||    ```
						| | 																			||   		||   	/  \
						| | 																			||   		||		 ||
						 v 																				||   		||	   /\
============================ 	===================     ||   		||
|| 												|| 													||   		||
|| 		Механизм вывода			|| 		модуль								||   		||
|| 												|| 			объяснений					||   		||
|| 												|| 													||   		||
|| 												|| 													||   		||
|| 												|| 													||   		||
============================ 	====================		||			||
						| | 												| |						||   		||
						| | 												| |						||   		||
						| | 												|	|						||   		||
						 v 													 v						||   		||
================================================== 		||			||
|| 		База данных					   || 								||		||			||
==================================================		||			||
 																											||			||
======================================================== 			||
||				интерфейс пользователя 															||
==============================================================||

		___
  ( `v` )   -- пользователь
  /     \
   (   )
    / \

Коллектив разработчиков
1. Заказчик
2. Эксперт
3. Программист
4. Инженер по знаниям

Этапы разработки
1. Выбор проблемы: 
 а) Определеные проблемной области и задачи
 б) Нахождение эксперта и назначение коллектива разработчиков
 в) Определение предварительного подхода к решению задачи
 г) Анализ расходов и ожидаемой прибыли
 д) Подготовка плана разработки
2. Разработка прототипа
| #этапа | название этапа | участники | результат |
---------------------------------------------------
| 	1		 | уточнение  	  |  ЗаЭкИзП  | проблема  | 
| 			 | 		проблемы  	| 				  |					  |
---------------------------------------------------
| 	2		 | получение  	  |  	ЭкИз 	  | знания 	  | 
| 			 | 		знаний	  	| 				  |					  |
---------------------------------------------------
| 	3		 |структурирование|  	 Из 	  |  поле 		| 
| 			 | 		знаний	  	| 				  |	знаний		|
---------------------------------------------------
| 	4		 |  формализация	|  	Из П 	  |  база 		| 
| 			 | 		знаний	  	| 				  |	знаний		|
---------------------------------------------------
| 	5		 |  реализация		|  		П 	  |  прототип	| 
| 			 | 		прототипа	  | 				  |						|
---------------------------------------------------
| 	6		 |  тестирование	|  ЗаЭкИзП  |  					| 
| 			 | 							  | 				  |						|
---------------------------------------------------

3. Развитие прототипа до промышленной экспертной системы
* Демонстрационный прототип
 -- Система решает часть задач, демонстрируя жизнеспособность подхода
* Исследовательский прототип
 -- Система решает большинство задач, но неустойчива в работе и не полностью проверена
* Действующий прототип
 -- Система решает все задачи на реальных примерах, но для сложных задач требует много ресурсов
* Промышленная система
 -- Полноценная система. Высокое качество решений при минимальных затратах
* Коммерческая система
 -- Полноценная система. Сервис и документация, легка для деплоя

4. Оценка системы - внешнее тестирование, проводимое приглашенными экспертами и заказчиками (проверяет интерфейс)
5. Стыковка
6. Поддержка и сопровождение

Модели представления знаний
1. Формальные логические модели
То что в прологе, ну туда

2. Семантические сети
Ориентированный граф. Вершины - понятия, дуги - отношения между ними.
Понятия - какие-то конкретные или абстрактные объекты
Если понятия: 
простые - простая сеть 
сложные - иерархическая сеть
Отношения:
. бинарные
. n-арные

Виды связи:
1| Часть-целое
2| Функциональные связи:
3| Количественные
4| Пространственные
5| Временн`ые
6| Атрибутивные
7| АКО (это есть)
...

=================           ============ 						==========					 	 ==========
||							||   это 										 это 									имеет
		Волга это       ------   автомобиль    -------  	вид        -------   двигатель
							      ------    						 ------- 	транспорта   -------
|| 							|| 					============						==========		частью	 ==========  
================== 								^
			|| 													|
			|| свойство 		\ 					| любит
											 \ владеет  |
		<цвет> 							\ 				|
 																	/ 		
			|| значение         <КОЛЯ>-/ 		----------  <Человек>

		<красный>


3. Фрейм

Канарейка -> Птица -> Летает
		|
		v
	Поет


4. Продукционные системы
f[<N1,V1>, ..., <Nk, Vk>]
	 слот
f - шаблон, <Ni, Vi> - слот, Ni - имя слота, Vi - значение слота

<K1><L1>, ..., <Km><Lm>, <R1>...<Rp>

Ki - атрибуты, характерные для слота, Li - их значения. Rj - ссылки на другие слоты