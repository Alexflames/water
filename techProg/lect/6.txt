__________________________________________________
|                                                 |
|Д/З: рассказать о Any проге, измер. сложность ПО |
|_________________________________________________|
Метрика Чепина
Оценка информационной прочности отдельно взятого программного модуля с помощью
анализа характера использования переменных из списка ввода-вывода

Q = a1 * P + a2 * M + a3 * C + a4 * T

P - вводимые переменные для рассчетов
M - модифицируемые или создаваемые внутри переменные
C - флаги, управляющие переменные
T - паразитирующие переменные, не несущие какой-либо функциональности

a1 = 1, a2 = 2, a3 = 3, a4 = 0.5

Примечание. Одна и та же переменная может быть в нескольких множествах

Метрика Джилба
Относится к количественным метрикам, измеряющим сложность программного обеспечения
на основе насыщенности программы условными операторами или операторами цикла

Метрика уровня комментированности программ
Общая формула: Nком / Nстр

Принято считать что приемлемое значение данного показателя - больше чем 0.5

Другая формула: делим весь модуль на N блоков равной длины, для каждого блока
коэффициент вычисляется отдельно. Fi = sign(Nком / Nстр - 0.1)

При этом: F = sum(i:= 1 to n)(Fi) и если будет равен N (кол-во блоков)

Метрика 'Модуль - глобальная переменная'
Метрика сложности потока данных. Как сложно модифицирировать программу, в том
числе по количеству глобальных переменных

Aup - сколько раз модули действительно получили доступ к глобальным переменным.
Pup - сколько раз могли бы получить доступ к глобальным переменным
Rup = Aup/Pup - чем меньше тем лучше, чем ближе к 1, тем хуже

Эта формула показывает приближенную вероятность ссылки произвольного модуля на 
произвольную глобальную переменную. Чем выше эта вер-ть, тем выше вер-ть
несанкционированного изменения какой-либо переменной что может осложнить работы 
связанные с модификацией программы

Размерно-ориентированные метрики. Прямое измерение программного продукта и
процесса его разработки.

LOC-оценка (Lines Of Code) может включать в себя:
  общие трудозатраты
  объем программы
  стоимость разработки
  объем документации
  ошибки, обнаруженные в течение года эксплуатации
  количество людей, работавших над изделием
  срок разработки

(Source)SLOC-оценка бывает двух видов

> Физические - определяется как общее число строк исходного кода, включая
комментарии и пустые строки. Пустые строки не будут считаться более 25% от кода

> Логические - количество команд

Существует большое количество вариаций метрики LOC

Недостатки метрики LOC.
о Процесс измерения может быть искажен за счет того что сотрудники знают об 
измеряемом показателе и оптимизируют код а не алгоритм
о Метрика не дает представления о сложности решенной проблемы
Следовательно, эта метрика может использоваться толкьо в совокупности с другими метриками

                              ABC-метрика
  Данный показатель ПО был введен Jereff(?) Fitzpatrick для преодоления
недостатков LOC. Определяет оценку как тройку значений. 
  A - количество операций присваиваний в коде (Assignments)
  B - количество вызовов функций (Branch)
  C - количество логических сравнений (Condition)
Как правило на основе данной тройки вычисляется обобщенный параметр - сложность
кода. Результат (sqrt(A^2 + B^2 + C^2)) округляется до первого знака после запятой. 
Оценка может иметь нулевое значение для некоторых непустых программных единиц

Правило для С++:
> Когда увеличиваем А. Когда возникает оператор присваивания, оператор сокращенных
действий (+= *=), инкремента, декремента, инициализация переменной или экземпляра
класса. [Исключения] - объявление константы. Назначение параметров метода по умолчанию.
> Когда увеличиваем B. Когда вызывается функция или метод классов и когда
возникает оператор new или ... . 
> Когда увеличивается C. Когда появляются ключевые слова: case, else, ?(тернарн),
try-catch и когда возникает унарный условный оператор.

Замечание: 1. метрика не зависит от стиля кодирования, 2. метрика линейная (показатель
для модуля представляет сумму баллов его подмодулей). 
3. Данный показатель зачастую используется в модулях для выявления среднего числа
ошибок (заменяет оценку LOC).

Нормированные метрики.
Роджер Прессман, Том де Марко, Шем Чидамбер.
1. Сцепление - показывает насколько сильно сцеплен код, насколько сильно
классы, методы, параметры методов связаны между собой и ссылаются друг на друга
Низкое сцепление говорит о том что данный код написан не оптимально так как
существуют автономные типы которые мало взаимодействуют друг с другом.
Приемлемый показатель: 0,6 - 1 

Первый вариант формулы: сцепление данных и параметров управления
                      1
C = 1 -  --------------------------------------
         di + 2ci + d0 + 2c0 + gd + 2gc + w + r

di - количество входных данных
ci - количество входных управляющих параметров
d0 - количество возвращаемых данных
c0 - количество возвращаемых управляющих параметров

Глобальное сцепление - в формуле участвуют только 5 и 6 параметры
gd - количество глобальных переменных, используемых для данных
gc - количество глобальных переменных, используемых для управления

Связанность окружения - последние 2 параметра
w - количество вызываемых модулей и типов данных 
w - количество модулей и типов которые вызывывают данный метод

2. Центростремительное сцепление
Показывает количество типов за пределами пакета которые зависят от типов
текущего пакета.

Ca = 0,35 R' / PC + 0,65f(N)

        ( 1, R >= N
f(N) =  { 
        ( R / N , R < N

PC - количество всех типов в исходном коде (во всем решении)
N - количество всех типов в пакете, который рассматривается
R - количество ссылок на типы рассматриваемого пакета из других пакетов
R' - количество типов в исходном коде, ссылающихся на типы пакета

Существует другой способ подсчета центростремительного сцепления - количество
модулей, зависящих от данного модуля.

3. Внешнее сцепление - количество типов внутри пакеты, которые зависят от типов за
пределами пакета. 

Cе = R / N
N - количество типов в пакете, 
R - количество типов пакета, которое используют типы вне типов пакета

4. Нестабильность
I = Cе / (Ca + Cе) ,

где Cе - внешнее сцепление, Сa - центростремительное сцепление

5. Недостаточная связность 

LCOM = 1 - (1 / M*F) * sum(i:= 0 to n)MF

M - количество методов в классе,
F - количество экземплярных полей в классе
MF - количество методов класса, имеющих доступ к определенному экземпляруному полю
