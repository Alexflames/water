Понятие о технологии программирования и основные этапы её развития.
    Технология - набор правил, методик и инструкций, позволяющих наладить
  производственный выпуск какого-либо продукта.
    Технология программирования - совокупность методов и средств, используемых
  в процессе разработки ПО.
    Программная инженерия - систематизированный подход к разработке,
  эксплуатации и выведению из обращения программных средств.

  Виды ТП.
      Технологии, используемые на конкретных этапах разработки или для решения
    отдельных задач этих этапов. В основе данного вида лежит конкретно
    применимый метод для решения конкретной частной задачи (изолированно от 
    всей системы в целом).
      Технология, охватывающая несколько этапов или весь процесс разработки.
    В основе базовый метод, определяющий совокупность подходов, применимых к 
    разработке.

  Задачи ТП.
    1) Технология программирования должна наладить производственный выпуск ПП (прогр. продук.)
    2) ТП должна сокращать стоимость ПП, при этом повышая его качество.

      Результат применения ТП - программа, действующая в заданной вычисл. среде,
    хорошо документированная и отлаженная, и доступная для понимания и развития 
    в процессе сопровождения.

      ТП в общем виде представляет собой набор след. инструкций:
    1) Указание последовательности выполнения техн. операций.
    2) Перечисление условий, при которых выполняется та или иная операция.
    3) Описание самой операции, где для каждой операции определяются исходные 
    данные и реультат
    4) Нормативы, стандарты критериев.
    5) Процессы планирования и оценки качеств 

      ТП в узком смысле - это способ создания программ, включает в себя знание
    ЯП и инструментальных средств.

  ТП в историческом контексте
    Этап №1 - Стихийное программирование - от появления, до середины 65-68х годов
      Особенность:
    1) Программа - это штучный товар
    2) Не существует регламентированных требований к программам
    3) Программирование - это искусство
    4) Преобладание интуитивной технологии в программировании (снизу вверх)
    Интуитивная технология заключается в том что программист сразу 
    приступает к составлении программы по заданию, при этом задание может
    несколько раз изменяться, и минимальная документация составляется
    постфактум. 
      Методика технологий снизу вверх: 
    1) задача разбивается на ряд подзадач
    2) программист пытается сначала решить подзадачу, и лишь потом
    их синхронизироваь вместе, выработав общий интерфейс
      Ступени первого этапа:
    1) появление первых программ на машинном языке. Сложность работы 
    программиста ограничивалась способностью отслеживать последовательность
    выполнения операций и места нахождения данных;
    2) появление ассемблеров, которое позволило вместо 
    двоичных/шестнадцатеричных кодов использовать символические имена данных
    и мнемонику кодов;
    3) появление языков высокого уровня позволила снизить детализацию операций.
    Это привело к усложнению программ;
    4) Значимым событием стало появление возможности использовать в ЯП подпрограммы.
    Что привело к появлению библиотек;
    5) для сокращения искажения данных было предложено использовать в ПодПрог.
    свои области для хранения локальных данных
      В конце 60-х годов разразился кризис программирования, повсеместно фирмы
    не успевают в срок завершить программный продукт. 
      Факторы кризиса:
    1) Программы были сложны, запутанны, разобраться мог только автор.
    2) Преобладаниеп простейших конструкций.
    3) Конструкция снизу вверх. Сначала делались подпрограммы -> в программу
    4) Интерфейсы программ получались сложными при сборке
    5) Исправление ошибок требовало большого количества времени
    6) Процесс тестирования и отладки занимал до 80% времени разработки программ.

    Этап №2 - Структурный подход к программированию
    (Вторая половина 60-х - 70-ые годы)
    Переход к технологии сверху вниз. Алгоритм:
    1) Задача разбивается на ряд подзадач
    2) Каждая из полученных подзадач анализируется с целью возможного 
    разбиения на подзадачи;
    3) Процесс заканчивается когда подзадачу невозможно / нецелесобразно
    разбивать дальше
    4) Программа конструируется иерархически от главной подпрограммы к
    подпрограммам нижнего уровня

      В основе структурного подхода лежит декомпозиция (разбиение на части)
    сложных систем с целью последующей реализации в виде отдельных небольших
    подпрограмм.
      Основы структурного программирования
    1) Сложный алгоритм выстраивается из соединения базовых структур
    соединяться структуры могут 2 способами: последовательно и путем вложения
    2) Развитие принципа модульности при разработке программы. Модуль - 
    смысловая часть, функционально законченный элемент программы. 
    Модуль должен иметь 1 вход и 1 выход. Каждый модуль программируется отдельно,
    а затем модули соединяются в единую сложную систему. Для модуля 
    разрабатывается заглушка модуля для проверки функционирования сложной системы
    В самом простейшем виде заглушка - модуль бездействия

      Этап №3 - объектный подход к программированию
      (середина 80-х - 90-ые года XX века)
      Основа данного этапа - ООП. 
      ООП - технология создания сложного ПО, основанная на представлении программ
    в виде совокупности объектов, каждый из которых является представителем 
    некоторого класса, а классы образуют иерархию с наследованием свойств.
    Взаимодействуют программные объекты друг с другом при помощи механизма 
    передачи сообщений.
      Достоинства:
      1) Более естественная декомпозиция
      2) Возможность ведения независимых разработок
      3) Предлагаются новые способы, основанные на механизмах:
        а) Абстрагирование - берем только нужные свойства
        б) Инкапсуляция - скрытие реализации
        в) Полиморфизм - разновидность стандартизации интерфейса 
        г) Наследование
      4) Возможности визуального проектирования интерфейса
      5) Расширения принципов работы с библиотеками

      Этап №4 - компонентный проход
      (конец 90-х - до нашего времени)
      Компонент - физически отдельно существующая часть ПО, которая 
    взаимодействует с необх. объектом через специализированный интерфейс
      Объекты компонента можно собирать в динамически вызываемой библиотеке и
    использовать в любом языке программирования, поддерживающим соотв. технологию.

      Особенности при разработке сложных программ (то, на что должна обращать
                внимание технология программирования)
      1) Сложность формального определения требований
      2) Отслеживание степени повторяемости кодов
      3) Анализ иерархии модуля
      4) Планирования разработки
      5) Определение отношения коллективной разработки (чем больше коллектив,
      тем сложнее организовать работу)
      6) Необходимость в нахождении взаимосвязей между специалистом предметной 
      области и разработчиком
      7) Создание универсальных библиотек, которые можно использовать в 
      дальнейшей разработке
      8) Компетентность разработчиков.
      9) Создание проектных спецификаций и выработка правил и методологий
      переноса информационных систем с одной платформы на другую

Понятие о трансляторе, компиляторе, интерпретаторе и среде разработки.
    Транслятор - программа или техническое средство, выполняющее трансляцию
  программы.
    Трансляция программы - преобразование программы, представленной на одном из
  ЯП, в программу на другом языке программирования
    Транслятор может выполнять дополнительные функции, например, диагностика ошибок
    Язык, на котором представлена входная программа - исходный язык, а сама
  программа - исходный код
    Выходной язык называется целевым языком, а выходная программа - 
  объектный код

    Виды трансляторов:
  1) Диалоговый транслятор - обеспечивает использование языка программирования 
  в режиме разделения времени. 
  2) Синтаксически-ориентированный - транслятор, на вход которого  подается  
  синтаксис и семантика языка, и транслирующий программу на другой язык
  3) Однопроходный - транслятор, создающий объектный модуль при однократном 
  последовательном чтении исходного кода
  4) Многопроходный
  5) Оптимизирующий - транслятор, выполняющий оптимизацию созданного кода перед
  записью в объектный файл.
  6) Обратный - транслирует из объектного модуля в код на языке программирования
  7) Текстовый - получает один исходный код, выдает измененный исходный код


Выделяют 2 основных вида трансляции:
а) Компиляция - это транслятор, преобразующий исходный код какого-либо ЯП
  на машинный код.

Алгоритм работы компилятора
1) Лексический анализ, разбор на лексемы(группы)
2) Синтаксический анализ - сопоставление с правилами грамматики
3) Семантический анализ - выявление отношения, связей
4) Создание на основе анализа промежуточного кода
5) Оптимизация промежуточного кода
6) Создание объектного кода

Часть транслятора - компоновщик(редактор связей). Его задача - добавить
статическую библиотеку или связывает с динамической

Распространяется исполняемый файл, который является некроссплатформенным.
Недостаток - медленный процесс компиляции
Превнесение изменений требует повторной компиляции

б) Интерпретация
Интерпретация - процесс чтения и выполнения кода (строчка за строчкой)
Распространяется исходный код

Интерпретация всегда является кроссплатформенной.

Недостатки: 
1) Выявление ошибок на стадии исполнении интерпретатором 
2) Скорость работы готовой программы

Смешанная реализация - сначала компилятор, потом интерпретатор
Для кроссплатформенных решений

Алгоритм работы:
1) Программа компилируется неполностью, до тех пор пока может представить
кроссплатформенный код (байткод)
2) Байткод - некий аналог исполняемого модуля, но выполнить его может не 
реальный процесс, а только виртуальная машина.
3) На машине исполнителя должна присутствовать виртуальная машина (интерпретатор),
позволяющий исполнить байткод.
Такие языки: Java, Python.

Система программирования - интегрированная среда разработки, которая включает
в себя (как правило): текстовый редактор, компилятор или интерпретатор,
отладчик, средства автоматизации сборки, инструменты для упрощенного 
конструирования интерфейса

Понятие о промышленном программировании

Для любительского программировании характерно:
  а) Создание программ для решения частных задач
  б) Небольшой тираж
  в) Программа является объектом творчества
  г) Данные программы не поддерживают полный цикл разработки ПО

Промышленные программы - продукция производственно-технического назначения
  а) Программа обладает непосредственной производительной силой
  б) Признаки промышленной продукции
  Промышленная продукция - результат труда, полученный в определенном месте и
  в определенное время и предназначенный для использования потребителем
  в целях удовлетворения его материальных или духовных потребностей

Промышленные программные продукты делятся на категории:
  1) Небольшие - сотни и тысячи операторов высокого уровня
  2) Средние - десятки и сотни тысяч операторов
  3) Большие - миллионы операторов
  4) Сверхбольшие - десятки миллионов и выше операторов высокого уровня

  В качестве примера, Windows XP - 45 миллионов

  Проблемы промышленных продуктов:
  а) Недостаток технической компетенции
  б) Плохое управление процессом разработки
  в) Зачастую разработчики дают необоснованные обещания заказчику
  г) Непонимание принципов разработки сложных систем

  Определение сложности:
  1) Структурное определение сложности - 
  простая система характеризуется тем, что человек уверенно может перебрать 
  все связи между её элементами (в сложной системе он это сделать не в состоянии)

  2) "Поведенческое" определение сложности - 
  сложная система всегда недетерменирована с точки зрения поведения

  Сложности разработки делятся на 2 группы (по Фредерику Бруксу):
  1) Сущности - те сложности, которые внутренне присущи сложности ПО
  2) Акциденции - не внутренние сущности, а сущности, сопутствующие производству,
  которые могут проявиться в определенных ситуациях.

  Принципы работы со сложными системами
  1) Абстракция и уточнение
  2) Модульность
  3) Избегание переиспользования - избегания повторения описания одних и тех же
  знаний.

  Любая сложная программа не может быть оценена по принципу правильности.
  Здесь стоит говорить о том, является ли она достаточно качественной или 
  недостаточно качественной.

  Качество программы определяет удовлетворение пользователя от работы с программой
  и удовлетворение разработчика.

Жизненный цикл ПО
  Разработка ПО - разновидность человеческой деятельности, основанной на принципах
  работы со сложными системами. 
  Основная идея работы жизненного цикла - 
    детализация: цели -> задачи -> подзадачи

  Жизненный цикл - все, что сопровождает ПО с момента идеи до момента удаления
  последней копии

  Основные элементы жизненного цикла
  1. Процессы       3. Роли
  2. Артефакты      4. Цели

  1. Совокупность взаимосвязанных действий, преобразующих некоторые входные
  данные в выходные

  Примеры процессов:
    Анализ предметной облатси
    Кодирование
    Сбор требований
    Сопровождение

  2. Создаваемые человеком информационные сущности, документы в достаточно
  общем смысле, участвующие в качестве входных данных и получающиеся в
  качестве результатов различных деятельностей

  Примеры артефактов:
    Программный код
    Документация
    Техническое задание (письменный и устный вид)

  3. Роль - абстрактная группа заинтересованных лиц, участвующих в деятельности
  по созданию и эксплуатации системы и решающих одни и те же задачи или имеющие
  одни и те же интересы по отношению к ней

  4. Цель - идея, являющаяся стержнем в рамках процесса, задачи или подзадачи.

  Существуют разработанные стандарты, регламентирующие процессы цикла ПО.
  Есть организация ISO - International Standards Organization. 
  В рамках организации существует комитет - системная программная инженерия.

  ЗАДАНИЕ НА доп. балл - просмотреть
  ГОСТ 34.601-90 российский аналог стандарта ISO/IEC 12207 

  Написать в тетради.

{
  Процессы жизненного цикла ISO/IEC 12207
  Определяет жизненный цикл ПО в виде трехступенчатой модели, состоящей из
  процессов, видов деятельности и задач.

  18 процессов в 4 общих группах:
  Приобретение ПО, Разработка ПО, Эксплуатация ПО, Поддержка ПО

  Процессы состоят из отдельных видов деятельности. 
  В совокупности 74 вида деятельности.

  Например у приобритения ПО:
    инициация приобритения, подготовка контракта, анализ поставщиков и т.д.

  Каждый вид деятельности нацелен на решение ряда подзадач.
  Всего определено 224 подзадачи.

  Например у "переноса ПО между платформами":
    разработка плана переноса, оповещение пользователей, выполнение анализа
    производимых действий
}

ISO/IEC 15288 Standards for Systems Engineering - System Life Cycle Processes
  Отличается от предыдущего нацеленностью на рассмотрение 
  программно-аппаратных систем в целом.

ОБЯЗАТЕЛЬНО СДЕЛАТЬ
======================================================================
//Проанализировать и описать стандарт гибкой методологии (один из тех на лекции)\\
======================================================================

Модель жизненного цикла ПО - структра, определяющая последовательность выполнения и взаимосвязи, действий и задач процессов на протяжении жизненного цикла
Модели жизненного цикла устанавливают принципы организации жизненного цикла.
Виды: 1) стандартные модели 2) гибкая методология

1) Big-Bang Model (модель большого взрыва)
Выделяются ресурсы, согласно ресурсам производится процесс работы над ПО
Получаемый результат
Данная модель подходит для учебных и академических проектов.
Особенность данной модели: 
а) Результат может не соотв. требованию заказчиков
б) Не подходит для сложных проектов
в) Плохо реализовано планирование проектов

2) Code & Fix Model
Модель со слабой формализацией, модель черного ящика
Применение: учебные или маленькие несложные проекты
Алгоритм данного проекта:
I) Формируется задание
II) Программист создает первый вариант кода
III) Заказчик оценивает, делает замечания
IV) Программист исправляет, возвращение к (III)
Замечания:
а) Нет затрат времени на проектирование
б) Не определены сроки проекта
в) Ошибки требуют повторного кодирования

3) Каскадная (водопадная/последовательная) модель.
Описана в 70-м году, автор О.У.Ройз
Стадии: планирование->формирование требований->анализ и проектирование->
->конструирование->интеграция и тестирование->поддержка и эксплуатация
Каскадная модель является моделью, выполняющая строго последовательно свои фазы.
Основной принцип - движение только вперед. Следующая фаза закончится начнется
только когда закончится предыдущая и будут созданы какие-то артефакты
Каждая фаза имеют строго определенные критерии входа и выхода
Каждая фаза строго документируется
Основа модели - ТЗ, которое не может измениться
Критерии качества - соответствие продукта установленным требованиям на каждом этапе
Наиболее важными критическими этапами являются "формирование требований" и 
"анализ и проектирование"
"формирование требований" - абстрактное описание функциональности будущего ПО 
независимо от технологий
"анализ и проектирование" - выбор технологии для описания абстрактной модели
Каждая стадия заканчивается выпуском набора документаций - каждую стадию может
разрабатывать независимая команда разработчиков
Легкость в применении
Легкость в осуществлении контроля
Недостатки:
о Заказчик увидит готовый продукт только в самом конце
о Риск срыва проекта из-за пропущенных ошибок
о (Если ошибка) Сбой и рост затрат при возврате на фазы назад
Применим 
а) Существуют четкие и не меняющиеся требования заказчика
б) Строятся относительно простые информационные системы
в) Повторно разрабатывается типовой продукт
г) Выпуск новой версии существующего продукта
Общая стратегия:
a) Определены все требования
b) Один цикл конструирования
c) Промежуточных версий не существует
Замечания:
Существуют модификации каскадных моделей в связи с тем что реализовать её в
классическом виде затруднительно
Варианты:
>Каскадно-возвратная модель
# Возврат в предыдущии стадии
# Возврат на любую предыдущую стадию

# V - образная модель
Разработана в конце 80-х годов, является стандартом для немецких
правительственных и оборонных проектов
Основной смысл: на базовых этапах проектирования планируется тестирование
Структура модели по стандарту STB-ISO/MAP122072003
Этапы:
1) Подготовка процесса разработки
2) Анализ требований к системе + План ввода в эксплуатацию
3) Проектирование архитектуры системы + план квалификационных испытаний
4) Проектирование программных средств + план испытаний модулей
5) Программирование и тестирование
6) Сборка и квалификационные испытания модулей
7) Сборка система и её квалификационные испытания
8) Приёмочные испытания
Преимущества:
о Планирование на ранних стадиях систем тестирования
о Обеспечение аттестации и верификации на всех этапах
о Простота в использовании
Недостатки:
% Трудности с проектированием параллельных событий
% Не предусмотрено динамическое изменение требований заказчика
Стратегия
1) Определены все требования
2) Проектирование параллельных событий
3) Один цикл конструирования

Следующая стандартная модель - инкрементная
Описана в 80-ые годы.
Подразумевает разработку ПО с линейной последовательностью стадий но в
несколько инкрементов (версий). 
Каждый инкремент подразумевает запланированное улучшение продуктов.
Каждая версия наращивает функциональность
Основная идея:
# В начале работы определяются все основные требования к системе
# Описывается приоритет требований и функциональности
# Согласно приоритетам реализуются промежуточные версии
# Каждая версия является полностью законченным и работоспособным продуктом
Последняя версия включает в себя весь заранее запланированный функционал

Причины использования: 1) Отсутствие у заказчика возможности профинансировать 
сразу весь проект
2) Отсутствие у разработчика необходимых ресурсов для реализации проекта
в сжатые сроки
3) Избегание "отторжения" проекта пользователем-заказчику

Преимущества
а) Итеративное тестирование
б) Равномерная загрузка участников проекта
в) Заказчик раньше увидит результаты и может незначительно скорректировать требования 

Стратегия:
1) Определены все требования
2) Множество циклов конструирования
3) Промежуточные версии могут распространяться

Спиральная (эволюционная, итерационная) модель
Барри Богэм, 1988 год
Основная идея: разработка в виде последовательных версий, но в начале
проекта определены не все требования. Требования уточняются в результате
разработки версии и отзывов пользователей

Особенности: 
о Модель характерна при разработке новаторских и нетиповых систем
о В начале работы над проектом у заказчика и разработчика нет четкого видения
итогового продукта
о Принимаются решения по разработке с возможностью изменения требований
или отказа от дальнейшего развития проекта

Достоинства:
о Позволяет быстро показать пользователям работоспособный продукт
о Активизируется процесс уточнения и дополнения требований, в том числе
с широким участием пользователей
о Гибкость в управлении проектом
о Данная модель позволяет создать более надежную и устойчивую систему
о Уменьшаются риски заказчика
о Промежуточный продукт является полностью работоспособным

Недостатки:
@ Увеличивается неопределенность разработчика в перспективах развития проекта
@ Неизвестно точное количество итераций 
@ Затруднены операции временного и ресурсного планирования

Стратегия: 
1) Определены не все требования
2) Множество циклов конструирования
3) Промежуточные инверсии могут распространяться


Разновидность №2. 
Гибкие методологии - серия подходов к разработке ПО, ориентированное на
использование итеративной разработки, с динамическим формирований требований
и обеспечение их реализации в результате постоянного взаимодействия
внутри самоорганизующихся рабочих групп, состоящих из специалистов различного профиля

Основные идеи:
1) Люди и взаимодействия важнее процессов и инструментов
2) Работающий продукт важнее исчерпывающей документации
3) Сотрудничество с заказчиком важнее согласования условий контракта
4) Готовность к изменению важнее следованию первоначальному плану
5) Непосредственное общение лицом к лицу

2010 год - манифест гибкой методологии
Основные тезисы:
1) Удовлетворение клиента за счет [ранней и бесперебойной] доставки ценного
программного продукта
2) Приветствие изменений требований даже в конце разработки
3) Тесное общение с заказчиком
4) Проектом занимаются мотивированные личности
5) Рекомендуемый метод передачи информации - личный разговор
6) Постоянная адаптация к изменяющимся обстоятельствам
7) Работающее ПО - лучший измеритель прогресса
8) Постоянное внимание к улучшению технического мастерства
9) Лучшие технические требования, дизайн и архитектура получаются у
самоорганизованной команды

Примеры: Scrum, экстремальное программирование, бережливое,
программирование чистой комнаты 

----------------------------------------------------------------------
Д/З: Описание
Требования 'языка' / 'нескольких ЯП' к правилам оформленияя программ
----------------------------------------------------------------------
Гибкие методологии:
Scrum (конспект)

Экстремальное программирование - относится к упрощенным методологиям организации 
разработки для небольших и средних команд разработчиков
Цель - создание продукта при неясных и быстро меняющихся требованиях

4 основных принципа:
  1) Итерации (2-3 недели)
  2) Принцип - простота решения - принимается первое простейшее решение проблем,
  усложнение возможно, но в рамках уже других итераций
  3) Интенсивная разработка группами до 10 человек и парное программирование
  4) Обратная связь с заказчиком, он вовлечен в процесс разработки до всех
  возможных тонкостей

Приемы:
  о Игра в планирование - сбор всех известных требований к системе, 
  расставляются по приоритетам, заказчик сообщает о необходимости той или иной
  функциональности, программист оценивает возможность её реализации
  Игра в планирование перед началом каждой итерации
  о Тесное взаимодействие с заказчиком - держите заказчика при себе или
  сами держитесь при заказчике
  о Общесистемные правила наименования
  о Простая архитектура => Рефакторинг
  о Парное программирование 
  о 40-часовая рабочая неделя - не больше!
  о Коллективное владение кодом
  о Небольшие релизы
  о Полное тестирование после каждой итерации

Бережливая разработка - базируется на методах концепции "бережливое производство"
[
  [Бережливое производство] - концепция управления производством предприятия,
  основанное на постоянном стремлении устранения всех видов потерь.
  Автор - Тайики Оно (фирма Тойота), Джеймс Вумэйкер, Дэниэл Джонс
  
  Основная задача - создание процесса непрерывного устранения потерь, т.е. 
  любых действий, которых потребляют ресурсы но не производят ценности.

  Виды потерь:
  1) Из-за перепроизводства 2) Потеря времени из-за ожидания
  3) При ненужной транспортировке 4) Из-за лишних этапов обработки
  5) Из-за лишних запасов 6) Из-за ненужных перемещений
  7) Выпуска дефектной продукции 8) Нереализованный творческий потенциал

  Два источника потерь согласно авторам: 
    1) Перегрузка сотрудников 2) Неравномерное выполнение операций

]
Авторы концепции "бережливая разработка ПО" - Мэри Поппендик, Том Поппендик -
выявили принципы провалов проектов по созданию ПО
1) Часто и неожиданно меняющиеся требования
2) Централизованное принятие решений
3) Жесткое управление объемами работ
4) Традиционный/линейный подход к разработке

Общие типы потерь:
1) Лишняя функциональная возможность
Цитата Джима Джонсона: "только 20% функиональных возможностей в типичном 
пользовательском ПО используются регулярно, около 2/3 редко"
Причина возникновления ненужных функциональных возможностей:
о Слабое понимание заказчиком что необходимо реализовать
о Слабое понимание разработчиком что нужно пользователю
о Конкуренты
о Разработка по каскадной модели (нет связи с разработчиком)
Пути решения: 
> начинать с малого (постараться с начала разработать 20% программного кода), 
который обеспечил бы 80% потребностей заказчика. Всю последующую функциональность
необходимо подтвердить или опровергнуть с широким участием потребителя
> убирать лишнее: если выясняется, что в системе возникнет ненужная функциональность, 
её нужно срочно убрать
> если выясняется, что функционал необходим только 5% пользователей, его необходимо убрать

2) Избыточное проектирование
Когда программист создает код более гибким не имея на это никаких предпосылок
В основе лежит психологическая особенность, связанная с нежеланием переделывать
то что было подготовлено ранее
Чаще всего такая гибкость оказывается несостоятельной и оборачивается ненужной
тратой времени

3) Поиск и исправление ошибок
Трудоёмкость исправлений и затрачиваемое на это время является 
сложнопрогнозируемыми увеличениями
При накоплении ошибок мы накапливаем неопределенность, связанную со временем
завершения проверки.
Необходимо создать условия, при которых бы возникало меньше ошибок и сокращалось
время устранения. Устранять ошибки нужно по мере их обнаружения
Причины появления ошибок:
1) нарушение технологий и принципов написания кода (как правило связано со
спешкой у опытных специалистов)
2) низкая квалификация, низкая культура кодирования

Признаки деструктивной культуры: 
1. Безразличие: "мне за это не платят, главное - сдача работы"
2. Травля в коллективе: злость, сарказм.
3. Ненависть к заказчику и пользователю (выражения типа "сами не знают чего хотят")
4. Ненависть к руководству
5. Ненависть к коллегам
6. Саботаж

Пути решения: развивать квалификацию программистов, следить за мотивацией и духом
команды, командный тренинг, набирать в команду высококвалифицированных спецов, 
новых людей добавлять по одному

Третья причина возникновения ошибок:
  неудачно выбранный инструментарий / платформа 

|=========================|
|Стиль оформления программ|
|=========================|
Д.Ван.Тассел "Помните: программы читаются людьми"

Стиль оформления програм включает: 
1) Правила и наименования объектов программ
2) Правила оформления модулей
3) Стиль оформления текстовых модулей

Правила именования объектов программ:
1. Никакого транслита
2. Принцип использования коротких имен (нежелательно, 
но в некоторых случаях можно и нужно - в локальных модулях)
3. Использование нотаций
3.1 CamelCase
UpperCamelCase
lowerCamelCase
3.2 snake_case
Kebab-case, Train-Case, SCREAMING_CASE

Исследования Момеда Шарифа показали, что информация в змеиной нотации 
воспринимается быстрее чем в верблюжьей 
3.3 Венгерская нотация sName iCount
К именам переменных добавляют символы, определяющие тип или смысл
s sz i p a g
g_iSpeed (глобальная целочисленная переменная, означающая скорость)
i -> int ix      d -> ind dba = b - a
n -> nFound      a -> func(int ax) c -> int
I Венгерскую нотацию рассматривают как стандартную систему сокращений
II В ЯП, где внутреннего механизма типизации не хватает, за счет венгерской
нотации типизацию расширяют
III При изменении типа переменных требуется изменять её имя
VI Имена функций обычно префиксами не снабжают 
V Нотация удобна для написания больших программ в неполнофункциональных редакторах

Л. Торвальдс : "Вписывание типа переменной в её имя ущербно - компилятор
и так знает типы и может их проверить, и это запутывает программиста"

4. Избегать близких по написанию имен
5. Не экономить на длине названия
6. Единый стиль наименования переменных
7. Сокращения опасны

-----------
Отсутствует лекция №5
-----------

__________________________________________________
|                                                 |
|Д/З: рассказать о Any проге, измер. сложность ПО |
|_________________________________________________|
Метрика Чепина
Оценка информационной прочности отдельно взятого программного модуля с помощью
анализа характера использования переменных из списка ввода-вывода

Q = a1 * P + a2 * M + a3 * C + a4 * T

P - вводимые переменные для рассчетов
M - модифицируемые или создаваемые внутри переменные
C - флаги, управляющие переменные
T - паразитирующие переменные, не несущие какой-либо функциональности

a1 = 1, a2 = 2, a3 = 3, a4 = 0.5

Примечание. Одна и та же переменная может быть в нескольких множествах

Метрика Джилба
Относится к количественным метрикам, измеряющим сложность программного обеспечения
на основе насыщенности программы условными операторами или операторами цикла

Метрика уровня комментированности программ
Общая формула: Nком / Nстр

Принято считать что приемлемое значение данного показателя - больше чем 0.5

Другая формула: делим весь модуль на N блоков равной длины, для каждого блока
коэффициент вычисляется отдельно. Fi = sign(Nком / Nстр - 0.1)

При этом: F = sum(i:= 1 to n)(Fi) и если будет равен N (кол-во блоков)

Метрика 'Модуль - глобальная переменная'
Метрика сложности потока данных. Как сложно модифицирировать программу, в том
числе по количеству глобальных переменных

Aup - сколько раз модули действительно получили доступ к глобальным переменным.
Pup - сколько раз могли бы получить доступ к глобальным переменным
Rup = Aup/Pup - чем меньше тем лучше, чем ближе к 1, тем хуже

Эта формула показывает приближенную вероятность ссылки произвольного модуля на 
произвольную глобальную переменную. Чем выше эта вер-ть, тем выше вер-ть
несанкционированного изменения какой-либо переменной что может осложнить работы 
связанные с модификацией программы

Размерно-ориентированные метрики. Прямое измерение программного продукта и
процесса его разработки.

LOC-оценка (Lines Of Code) может включать в себя:
  общие трудозатраты
  объем программы
  стоимость разработки
  объем документации
  ошибки, обнаруженные в течение года эксплуатации
  количество людей, работавших над изделием
  срок разработки

(Source)SLOC-оценка бывает двух видов

> Физические - определяется как общее число строк исходного кода, включая
комментарии и пустые строки. Пустые строки не будут считаться более 25% от кода

> Логические - количество команд

Существует большое количество вариаций метрики LOC

Недостатки метрики LOC.
о Процесс измерения может быть искажен за счет того что сотрудники знают об 
измеряемом показателе и оптимизируют код а не алгоритм
о Метрика не дает представления о сложности решенной проблемы
Следовательно, эта метрика может использоваться толкьо в совокупности с другими метриками

                              ABC-метрика
  Данный показатель ПО был введен Jereff(?) Fitzpatrick для преодоления
недостатков LOC. Определяет оценку как тройку значений. 
  A - количество операций присваиваний в коде (Assignments)
  B - количество вызовов функций (Branch)
  C - количество логических сравнений (Condition)
Как правило на основе данной тройки вычисляется обобщенный параметр - сложность
кода. Результат (sqrt(A^2 + B^2 + C^2)) округляется до первого знака после запятой. 
Оценка может иметь нулевое значение для некоторых непустых программных единиц

Правило для С++:
> Когда увеличиваем А. Когда возникает оператор присваивания, оператор сокращенных
действий (+= *=), инкремента, декремента, инициализация переменной или экземпляра
класса. [Исключения] - объявление константы. Назначение параметров метода по умолчанию.
> Когда увеличиваем B. Когда вызывается функция или метод классов и когда
возникает оператор new или ... . 
> Когда увеличивается C. Когда появляются ключевые слова: case, else, ?(тернарн),
try-catch и когда возникает унарный условный оператор.

Замечание: 1. метрика не зависит от стиля кодирования, 2. метрика линейная (показатель
для модуля представляет сумму баллов его подмодулей). 
3. Данный показатель зачастую используется в модулях для выявления среднего числа
ошибок (заменяет оценку LOC).

Нормированные метрики.
Роджер Прессман, Том де Марко, Шем Чидамбер.
1. Сцепление - показывает насколько сильно сцеплен код, насколько сильно
классы, методы, параметры методов связаны между собой и ссылаются друг на друга
Низкое сцепление говорит о том что данный код написан не оптимально так как
существуют автономные типы которые мало взаимодействуют друг с другом.
Приемлемый показатель: 0,6 - 1 

Первый вариант формулы: сцепление данных и параметров управления
                      1
C = 1 -  --------------------------------------
         di + 2ci + d0 + 2c0 + gd + 2gc + w + r

di - количество входных данных
ci - количество входных управляющих параметров
d0 - количество возвращаемых данных
c0 - количество возвращаемых управляющих параметров

Глобальное сцепление - в формуле участвуют только 5 и 6 параметры
gd - количество глобальных переменных, используемых для данных
gc - количество глобальных переменных, используемых для управления

Связанность окружения - последние 2 параметра
w - количество вызываемых модулей и типов данных 
w - количество модулей и типов которые вызывывают данный метод

2. Центростремительное сцепление
Показывает количество типов за пределами пакета которые зависят от типов
текущего пакета.

Ca = 0,35 R' / PC + 0,65f(N)

        ( 1, R >= N
f(N) =  { 
        ( R / N , R < N

PC - количество всех типов в исходном коде (во всем решении)
N - количество всех типов в пакете, который рассматривается
R - количество ссылок на типы рассматриваемого пакета из других пакетов
R' - количество типов в исходном коде, ссылающихся на типы пакета

Существует другой способ подсчета центростремительного сцепления - количество
модулей, зависящих от данного модуля.

3. Внешнее сцепление - количество типов внутри пакеты, которые зависят от типов за
пределами пакета. 

Cе = R / N
N - количество типов в пакете, 
R - количество типов пакета, которое используют типы вне типов пакета

4. Нестабильность
I = Cе / (Ca + Cе) ,

где Cе - внешнее сцепление, Сa - центростремительное сцепление

5. Недостаточная связность 

LCOM = 1 - (1 / M*F) * sum(i:= 0 to n)MF

M - количество методов в классе,
F - количество экземплярных полей в классе
MF - количество методов класса, имеющих доступ к определенному экземпляруному полю

---------------------
Отсутствует лекция №7 (последняя)
---------------------