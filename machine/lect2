.........
Лекция2
Байты могут объединяться в поля - поля переменной и фиксированной длины
Фиксированной - имеют собственные имена, слово состоит из 2 байтов, двойное слово из 4 байтов
Длина поля - кол-во входящих в него байтов, адрес поля - адрес младшего входящего в поле байта
Адрес поля может быть любым, но если флажок АС установлен 1, то адрес слова должен быть кратен 2, а двойного слова - 4.

Оперативная память может использоваться как непрерывный массив байтов или как сегментированная память.
В этом режиме физический адрес байта записывается следующим образом - сегмент:смещение.
Или если записать с помощью формулы - физический адрес = адрес сегмента + исполняемый адрес (ИА).
ИА (смещение) формируется различным способом в зависимости от способа адресации операндов в команде. 
В защищенном режиме программа может определить и использовать до 16383 сегментов размером до 4 Гб, 
и таким образом может работать с 64 Тбайтами виртуальной памяти.
Для реального режима адрес сегмента определяется сегментным регистром, но для 
получения 20-разрядного двоичного адреса нужно содержимое сегментного регистра сместить на 4 разряда влево, 
и к нему прибавляется 16-разрядное смещение - ИА

Например, адрес следующей исполняемой команды:
      __
ФА = (CS) + (IP)
(CS) = 7A15_16 = 01111010000101010000_2
(IP) = C7D9_16 = ....1100011111011001_2
 ФА = 86929_16 = 10000110100100101001_2  Физический адрес!

================
 Форматы данных.
================
Рассматриваемый процессор может работать с целыми двоичными без знака, с целыми двоичными со знаком,
с действительными с плавающей точкой, двоично-десятичными, со строками и указателями.
Двоично-десятичные без знака могут занимать байт, слово или двойное слово и принимать
значение из диапазона [0; 255] для байта, [0; 65535] для слова, 
и для двойного слова [0; 4294967295]
Двоичные со знаком тоже могут занимать байт, слово или двойное слово, хранятся в
дополнительном коде и формат его такой, что 7, 15 или 31 - знаковый разряд, 
0, +, 1, -, а остальные - цифровые
Дополнительный код в любой СС может быть получен по формуле X = 10^n - |X|, где 
n - разрядность числа. Например, если есть -AC7_16, то в слове:
10^4 - AC7 = F539.
Дополнительный код двоичного числа получается инверсией разрядов и прибавлением '1' к младшему разряду.

Например, 12 в байте = 00001100
          инверсия   = 11110011
  дополнительный код = 11110100

Вычитание в машине. 
...
65 - 42 = 23  

Числа с плавающей точкой могут занимать 32 разрядов(бит), 64 или 80 разрядов и 
называются соответственно "короткое вещественное(32)", "длинное вещественное(64)" и
"рабочее вещественное(80)"
Формат числа с плавающей точкой состоит из 3 полей: знак числа, машинный порядок, мантисса.
Для короткого вещественного 1 +  8 + 23: - 10^(+-32)   -- + 10^(+-32)
    длинного                1 + 11 + 52: - 10^(+-308)  -- + 10^(+-308)
    рабочего                1 + 15 + 64: - 10^(+-4932) -- + 10^(+-4932)

Машинный порядок в неявном образве включает в себя знак порядка и связан с истинным порядком 
следующей формулой: Пм = Пи + (127_10 для короткого, 1023_10 для длинного, 16383_10 для рабочего)

Мантисса должна быть нормализованной, причем старшая единичка не записывается в разрядную сетку. 

31-30-------------------23-22--------------------0
знак      М.порядок                Мантисса

3060_10 в виде числа с плавающей точкой:

1) Переводим из _10 в _16 
3060_10 = BF4_16

2) Нормализуем число BF4 * (10^3)_16

3) Получим машинный порядок Пм = 3_16 + 7F_16 = 82_16

4) Запишем в разрядную сетку в 2-ичной СС:
0 1000 0010 011 1111 0100 0000 0000 0000_2

Или в 16-ричном виде: 413F4000_16


Двоично-десятичные числа процессор может обрабатывать 8-разрядные в упакованном и
неупакованном формате, и сопроцессор может обрабатывать 80-ти разрядные данные в упакованном формате.
Упакованный формат предполагает хранение 2 цифр в байте, 
а неупакованный - 1 цифра в цифровой части байта.
Строки - последовательности байтов, слов или двойных слов, каждому символу отводится 1 байт,
и представляются они в ASCII коде

Указатели могут быть 2 типов: а) 48 разрядов селектор(16) + смещение(32) или 
б) только смещение (32 разряда/бита)

==============|
Форматы команд|
==============|
Команда - последовательность двоичных кодов, разделенная на 2 подпоследовательности
Одна говорит процессору, что нужно сделать, определяет операцию, а вторая часть говорит, 
где взять данные, операнды и куда отправить результат.
Рассматриваемый процессор может работать с безадресными командами, с 1-адресными, 
2- и 3-адресными командами, при этом данные могут находиться в регистрах, в
оперативной памяти или непосредственно в команде. 
Команда может занимать в памяти различное количество байтов (до 15), и это 
зависит от выполняемой операции (от кода), от количества операндов и места их расположения.
Наиболее часто используются 2-адресные команды, и формат их может быть 
R-R    M-M    R-M    M-R     R-D    M-D
где R - регистр, M - память, D - данные

Существуют различные способы адресации операндов, размер может быть байт, слово или Dслово.
Адресации:
1) регистровая
2) непосредственная (операнд в команде) 
3) прямая
4) косвенно-регистровая
5) по базе со смещением
6) прямая с индексированием
7) по базе с индексированием
В защищенном:
8) 9) 10) (Учить не надо)

Примеры команд с различными способами адресации
1) Регистровая
Результат пересылается по адресу первого операнда
MOV AX, BX ; (BX) -> AX
Машинный формат: 1001 0011 1100 0011
"код операции" 100100
"d" = 1   "mod" = 11  "r/m" = 011
"w" = 1   "reg" = 000 

2) Непосредственная (непосредственно в команде содержится операнд)

MOV AX, 25 ; 25 -> AX
CONST EQU 34h ; именованная константа CONST, директива EQU
MOV AX, CONST ; 34h -> AX

3) Прямая адресация
Если известен физический адрес операнда, то в команде его можно записать так:
MOV AX, ES : 0001
ES - регистр сегмента данных, 0001 - смещение внутри сегмента
Содержимое двух байтов начиная с адреса (ES) + 0001 пересылаются в AX - 
((ES) + 0001) -> AX

Прямая адресация может быть записана с помощью символического имени, которому 
предварительно был поставлен в соответствие некоторый адрес, а это можно сделать 
с помощью директив определения данных и памяти, например: 
DB - (define) байт
DW - слово  DD - двойное слово

Если в сегменте ES содержится директива Var_p DW ?, тогда по команде
MOV AX, ES : Var_p ; ((ES) + Var_p) -> AX
(Содержимое двух байт памяти начиная с ES перешлется в AX)
MOV AX, Var_p; ((DS) + Var_p) -> AX
(Данные - переменная по умолчанию размещаются в сегменте, на который указывает DS.
Содержимое двух байт памяти начиная с DS посылаются в AX)

4) Косвенно-регистровая. 
Отличается от регистровой тем, что в регистре содержится адрес операнда, а не операнд

В записи команды отличается тем, что регистр в команде записывается в [квадратных скобках]
Нельзя использовать регистры AX, CX, DX, SP, ESP

5) По базе со смещением
(Должен быть использован базовый регистр)

MOV AX, [BX] + 2      ; ((DS) + (BX) + 2) -> AX
MOV AX, [BX + 2]      ; Эквивалентны
MOV AX, 2[BX] 

MOV AX, [BP + 4]      ; ((SS) + (BP) + 4) -> AX 

6) Прямая с индексированием позволяет работать с одномерными массивами и
полями структур, например:
MOV AX, MAS[SI] ; ((DS) + (SI) + MAS) -> AX
Можно работать с одномерными масствами. Символическое имя определяет начало массива, а содержимое индексного регистра позволяет переходить от 1 элемента массива к другому 

7) По базе с индексированием позволяет работать с двумерными массивами или с массивами структур. 
MOV AX, Arr[BX][DI] ; ((DS) + (BX) + (DI) + Arr) -> AX
Arr определяет адрес начало массива. С помощью DI идём от 1 элемента в строке к другому, 
с помощью BX переходим от 1 строки к другой

Особенности использования команд пересылки 
1) Нельзя переслать информацию (с помощью MOV) от 1 области памяти в другую
2) Нельзя переслать информацию из 1 сегментного регистра в другой 
3) Нельзя переслать непосредственный операнд (константу) в сегментный регистр, можно
в качестве промежуточного использовать регистр общего назначения
MOV DX, 100h
MOV DS, DX 
4) Нельзя изменять командой MOV содержимое регистра CS
5) Данные в памяти хранятся в перевернутом виде, а в регистрах в "нормальном", 
команда пересылки учитывает это
R DW 1234h  
В байте с адресом R будет 34h, в байте с адресом R+1 будет 12h
MOV AX, R ; 12h -> AH, 34h-> AL
6) Размер передаваемых данных определяется типом операндов
X DB ?     ; X - 1 байт  в памяти
Y DW ?     ; Y - 2 байта в памяти
MOV X, 0   ; очищение одного байта в памяти
MOV Y, 0   ; очищение двух  байтов в памяти
MOV AX, 0  ; очищение двухбайтового регистра
MOV [SI], 0; сообщение об ошибке

Если тип обоих операндов не определен, то необходимо использовать для определения типа
операндов оператор PTR
<тип> PTR <выражение>
Выражение может быть адресным или константным, а тип определяет размер операнда
BYTE, WORD, DWORD, FWORD, QWORD, TWORD и т.д.

byte PTR 0 ; 0 как байт
word PTR 0 ; 0 как слово
byte PTR op1 ; 1 байт в памяти начиная с адреса op1
MOV byte PTR [SI], 0
или
MOV [SI], byte PTR 0; 
MOV [SI], word PTR 0; 0 -> ((DS) + (SI))