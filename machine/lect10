Рекурсия

Основная проблема - опасность зацикливания, передача параметров
Чтобы зацикливание не произошло, нужно, чтобы было 2 ветви в подпрограмме
Рекурсивная и нерекурсивная, и при выполнении некоторого условия 
вычисление должно идти по нерекурсивной ветви

Нельзя передавать параметры через глобальные переменные в сегменте данных, если
такая необходимость возникает, то при входе в подпрограмму 
эти параметры нужно переслать в стек, а при выходе из подпрограммы восстановить

Поиск N-го члена ряда фибоначчи
F(n) = 1, если n = 0/1
F(n) = F(n-1) + F(n-2)
  Номер ряда в регистре AL, Значение в регистре BX

  Fib proc
    cmp AL, 1
    ja m1         ; если n > 1 -----> m1 
    mov BX, 1
    ret

m1: push AX
    dec AL        ; AL = n-1
    call Fib      ; BX = F(n-1)
    push BX
    dec AL
    call Fib      ; BX = F(n-2)
    pop AX        ; AX = F(n-1)
    add BX, AX    ; BX = F(n-2) + F(n-1)
    pop AX
    ret
  Fib endp

=Работа со строками в ассемблере=
Строка в ассемблере - последовательность байтов, слов или двойных слов. 
Все команды работы со строками считают, что строка-источник находится по адресу
DS:SI (DS:ESI), а строка - приемник по адресу ES:DI (ES:EDI)
Все команды работают только с одним элементом строки - байтом, словом или dword
и чтобы выполнить действие со всей строкой нужно использовать специальный префикс 
повторения. Эти префиксы действуют только на команды работы со строками. Если 
записать перед любой другой командой никакого воздействия не произойдет.
  rep   - повторять
  repe  - повторять пока равно
  repz  - повторять пока ноль
  repne - повторять пока не равно 
  repnz - повторять пока не ноль

rep <строковая команда> заставляет выполнять эту команду n раз, где n - 
содержимое регистра CX или ECX
Если CX = 0, то rep ни разу не выполнится.

repe = repz
Следующая за ней строковая команда будет повторяться пока ZF = 1, но не более n раз,
где n - содержимое регистра CX или ECX

На псевдокоде:
  m: if (CX) = 0 then goto m1;
        (CX) = (CX) - 1;
        <строковая команда>;
        if ZF = 1 then goto m;
  m1:

  repne = repnz 
  То же самое только пока ZF = 0.

На псевдокоде:
  m: if (CX) = 0 then goto m1;
        (CX) = (CX) - 1
        <стр. команда>
        if ZF = 0 then goto m;
  m1:

Префикс rep используется с 
  movs, lods, stos, ins, outs
Префиксы repe, repz, repne, repnz с командами
  cmps и scas 
        Команды копирования строк
  1) movs op1, op2 ; источник op2 = DS:SI (DS:ESI), приемник op1 = ES:DI(ES:EDI)

  2) movsb ; байт данных из (DS:SI пересылается в ES:DI)
  3) movsw ; слово данных из (DS:SI пересылается в ES:DI)
  4) movsd ; дв. слово данных из (DS:SI пересылается в ES:DI)

  При использовании командды 1) movs ассемблер сам определяет сколько байтов
  данных нужно переслать - 1, 2 или 4

  В этой команде можно изменить DS на другой регистр: ES, GS, FS, CS, SS, но
  регистр операнда приемника ES изменять нельзя

  После выполнения любой строковой команды содержимое регистров SI и DI 
  автоматически изменяется в зависимости от значения флажка DF
    Если DF = 0, то (SI/ESI) и (DI/EDI) увеличивается на 1 или 2 или 4
    Если DF = 1, то (SI/ESI) и (DI/EDI) уменьшается на 1 или 2 или 4
    Зависит от типа операндов.

          Команды сравнения строк
  1) cmps op1, op2
  2) cmpsb
  3) cmpsw
  4) cmpsd

  1) в зависимости от типа операндов сравнивается содержимое байтов, слов или дв.слов
  расположенных по адресам источника и приемника

  Используются с префиксами repe/repz и repne/repnz

  1) scas op1 ; op1 - приемник ES:DI
  2) scasb    ; сравнивает (AL) с байтом из ES:DI 
  3) scasw    ; 
  4) scasd

  Сравнивает содержимое регистра-аккумулятора с байтом/словом/дв.словом с областью
  памяти по адресу ES:DI
  Первый вариант команды сам определяет сколько 

  Команды считывания строки из памяти и загрузки и загрузка в регистр-аккумулятор
  1) lods op2 ; op2 - источник DS:SI  или DS:EDI
  2) lodsb
  3) lodsw
  4) lodsd    ; 4 байта из DS:SI или DS:EDI --> EAX

  В lods можно заменить DS на другие сегментные регистры (ES, FS, GS, CS, SS)

  Команда записи строки из аккумулятора в память по адресу ES:DI или ES:EDI
  1) stos op1
  2) stosb
  3) stosw
  4) stosd

  При использовании команды с префиксом можно заполнить строку содержимым аккумулятора.

  Считывание из порта ввода/вывода
  1) ins op1, DX
  2) insb
  3) insw
  4) insd

  Считывают из порта ввода-вывода, номер которого записан в регистре DX
  байт, слово, двойное слово, которые пересылаются в область памяти по адресу
  ES:DI или ES:EDI.

  Если эту команду использовать с префиксом повторения, то можно из порта 
  ввода-вывода записать целый блок данных, и записать в память. Размер блока
  определяется содержимым регистра CX.

  И наоборот из памяти в порт можно вывести с помощью
  1) outs DX, op2
  2) outsb
  3) outsw
  4) outsd

  В команде outs можно заменить DS на ES, FS, GS, CS, SS

  Команды управления флагами
  cld  ; Clear Df, DF = 0
  std  ; Set   DF, DF = 1

  stc  ; CF = 1
  clc  ; CF = 0
  cmc  ; инвертирует флаг переноса
  lahf ; коирует младший байт регистра FLAGS в AH
  sahf ; из AH загружает флажки SF, ZF, AF, PF, CF
  cli  ; IF = 0
  sti  ; IF = 1
  salc ; установить AL в соответствии с CF

  Загрузка адресов сегментных регистров
    lds op1, op2
    les op1, op2
    lfs op1, op2
    lgs op1, op2
    lss op1, op2
  Для всех команд op2 - переменная в ОП размером в 32 или 48 бит в зависимости от
  разрядности операндов. Первые 16 загружаются в соответствующий сегмент, 
  а следующие 16 или 32 - в регистр общего назначения, указанный в качестве
  первого операнда.

  Например:
    S1 DB "ABC$"
    ADR DD S1
        les DI, ADR

  Пример 1 использования команд работы со строками:
    X DW 100 dup (?)
    Y DW 100 dup (?)
  Переслать из Y в X.
  -----------------------
    CLD       ; DF = 0
    lea SI, Y ; DS:SI - начало Y
    push DS   
    pop ES    ; (ES) = (DS)
    lea DI, X ; ES:DI - приемник
    mov CX, 100
rep movsw
  -----------------------

  Пример 2. В строке S из 500 символов заменить первое вхождение * на точку

  -----------------------
  CLD ; просмотр слева направо
  push DS
  pop ES   ; (ES) = (DS)
  lea DI, S; ES:DI - приемник
  mov CX, 500
  mov AL, '*'
  repne scasb ; сканирование строки S и сравнение с (AL)
  jne finish  ; в строке нет '*'
  mov byte ptr ES:[DI-1], '.'  ; вернулись на 1 байт(строка из байт) назад.
finish:
  ------------------------

====Строки переменной длины====
  Также как и в языках высокого уровня появляется необходимость работы со строками
  переменной длины. В Ассемблере можно объявить такую строку как в C++, а можно
  как в Pascal. 

  В С/С++ строка заканчивается символом - признаком конца строки. Если длину
  строки нужно изменить, то придется переносить этот символ влево или вправо

  В Pascal длина строки записывается в начале строки
  S: | n | S1 | S2 | .... | Sn | .. |

  Если сравниваем строки в стиле С/С++ различной длины, то в худшем случае придется
  выполнить n сравнений: 500/1000. Если со строками в стиле Pascal, то можно сразу
  сравнить длину строки.

  Строку из 200 символов можно описать так: 
    S DB 201 dup (?)  
  Длина строки по адресу S, а каждый символ по адресу S + i

  Пример 3. Удалить из строки S первое вхождение символа звездочка.
  push DS
  pop ES        ; (ES = DI)
  lea DI, S + 1 ; ES:DI по адресу S[1]
  CLD           ; просмотр вперед
  mov CL, S     ; текущая длина строки
  mov CH, 0     ; в CX
  mov AL, '*'   
  repne scasb   ; поиск '*' в S
  jne finish    ; '*' нет -> на finish
  ; удаление '*' из S, сдвинуть S на 1 символ S_i = S_i+1
  mov SI, DI    ; DS:SI = адресу, откуда начинать пересылку
  dec DI        ; ES:DI = куда пересылать
  rep movsb     ; сдвиг "хвоста" S на 1 позицию влево
  dec S         ; уменьшаем текущую длину на 1
  finish: 