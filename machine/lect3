Лекция 3.
Если тип обоих операндов при пересылке определен, то нужно, чтобы они соответствовали
друг другу.

R DW 1234h            ; R = 1234h
MOV AL, byte PTR R    ; (AL) = 34h
MOV AL, byte PTR R+1  ; (AL) = 12h

К команде пересылки относят:
1) команду обмена значений операндов. XCHG OP1, OP2
MOV AX, 10h
MOV BX, 20h
XCHG AX, BX           ; (AX) = 20h, (BX) = 10h

Для i386 и выше доступна следующая команда
2)BSWOP - перестановка байтов внутри регистра
(Точками отделены байты)
(EAX) = 12.34.56.78
BSWOP EAX             ; (EAX) = 78.56.34.12h

3) команды конвертирования:
CBW ; Byte - word  | (AL) -> AX
CWD ; Word - Dword | (AX) (DX:AX)
CWE ; (AX) -> EAX (для i386 и выше)
DF  ; (EAX) -> EDX:EAX

4)CMOVxx - условная пересылка
CMOVL AL, BL ; если (AL) < BL, то (BL) -> AL

5)Загрузки адреса
LEA OP1, OP2 ; вычисляет адрес второго операнда, пересылается в регистр указанный первым
             ; операндом
LEA BX, M[BX][DI] ; адрес по базе с индексированием

|================================|
|Структура программы на Assembler|
|================================|
Assembler - язык программирования низкого уровня. Программа написанная на данном
языке должна пройти 3-4 этапа обработки
1) Исходный модуль преобразуется в объектный модуль (Ассемблирование)
Программа, записывается в код машины. Исходных модулей может быть 1 или несколько
2) С помощью программы компоновщика и редактора связей объектный модуль объединяется в
загрузочный исполняемый модуль - файл с расширением .exe 
3) Этот файл может быть выполнен. 
Однако кроме исполняемого .exe файла существует исполняемый .com файл
На втором этапе .exe файл, а чтобы получить .com нужно выполнить ещё 1 этап обработки,
на котором .exe файл преобразуется в .com файл но при условии, что исходный
удовлетворен определенным требованиям.

Программа на Ассемблере состоит из команд и директив. Команды преобразуются в коды
машины и реализуют алгоритм поставленной задачи, а директивы определяют форматы данных,
выделяют место в памяти для них и говорят, каким образом нужно провести 
ассемблирование и редактирование.
В общем виде формат команды можно представить следующим образом:
[<имя>[:]] <код операции> [<операнды>] [;комментарии]
Написанное в квадратных скобках может не быть.
Поля отделяются друг от друга хотя бы 1 пробелом. Имя - символическое имя ассемблера,
которое используется как метка команды для передачи управления на эту команду, и если
после имени присутствует двоеточие, то это говорит о том, что метка внутренняя,
т.е. на эту команду можно передать управление только из этого кодового сегмента, 
в котором она содержится
Код операции говорит, что сделать нужно
Операнды могут отсутствовать, а если есть, то может быть 1, 2 или 3 операнда,
разделенные запятыми.
Комментарий всегда начинается с ';'. И может занимать часть строки или всю строку

Пример:
JMP M1 ; команда безусловнойпередачи управления на команду с меткой М1
M1: MOV AX, BX

Директива, так же как и команда может состоять из 4 полей
[<имя>] <код псевдооперации> <операнды> [;комментарии]
<имя> - символическое имя Ассемблера. 
<Код псевдооперации> определяет назначение директивы
У одной директивы может быть различные количество операндов

Например:
M1 DB 1, 0, 1, 0, 1 ; директива DB определяет 5 байтов памяти и заполняет их 0 
                    ; или 1 соответственно, и адрес первого из этих байтов присваивается
                    ; переменной М1
Proc    ; директива начала процедуры
endp    ; директива конца процедуры
Segment ; директива начала сегмента
ends    ; директива конца сегмента

Исходный модуль на Ассемблере состоит из команд, директив и комментариев и оформляется 
с помощью 3 сегментов и заканчивается директивой end, которая на этапе ассемблирования 
говорит о конце исходного модуля.

Первый вариант структуры программы
Sseg Segment...
----/----
Sseg ends

Dseg Segment...
----/----
Dseg ends

Cseg Segment
----/----
end start

end - конец модуля, а её параметр определяет точку входа в программу
В нашем случае с команды с меткой start начнется выполнение программы.

Назначение сегментов определяется параметрами в директивах начала сегмента и
кроме того в кодовом сегменте сразу за директивой Segment должна располагаться директива,
устанавливающая соответствие между именами в директивах Segment и сегментными регистрами.
ASSUME SS:SSeg, DS:DSeg, CS:CSeg, ES:DSeg
На Dseg ссылаются и DS, и ES. Это будет необходимо для работы со строками

Кодовый сегмент может быть оформлен как одна процедура, как несколько
поледовательных процедур или комбинация последовательных и вложенных процедур.

Кодовый сегмент можно представить следующим образом если он состоит из вложенных процедур
Cseg Segment
ASSUME SS:SSeg, DS:SSeg, CS:CSeg
pr1 Proc Far  
---/---
  pr2 Proc
  ---/---
  pr2 endp
---/---
pr1 endp
Cseg ends ; имя совпадает с началом сегмента

В сегменте стека выделяется место под стек (определется его размер)
В сегменте данных описываются исходные данные, и выделяется место под 
промежуточные/окончательные результаты
В кодовом сегменте решается поставленная задача

Шаблон программы с использованием директив стандартной сегментации.
; Prim1.ASM

Sseg Segment
  DB 256 DUP(?) ; ничем не заполняем <=> (?)
Sseg ends

Dseg Segment
  X DB 'A'
  Y DB 'B'
  Z DB 'C'
Dseg ends

Cseg Segment
  ASSUME SS:SSeg, DS:DSeg, CS:CSeg
  Start Proc FAR
    Push DS
    Push AX
    MOV DX, DSeg
    MOV DS, DX
    CALL Main
    Ret
  Start endp
  Main Proc NEAR
    ADD AL, X
    MOV AX, Y
    ---/---
    RET
  Main endp
  Cseg ends
end Start

В данном примере кодовый сегмент состоит из 2 последовательных процедур
1) Start - внешняя(параметр FAR), и внешняя потому что обращаемся к ней из ОС / отладчика,
команда 148 и 149 сохраняет в стеке DS и AX (реализует связь с ОС), а 150 и 151
загружает в регистр DS адрес нашего сегмента данных
Следующая команда обращается к внутренней (параметр Near) процедуре с именнем Main. 
К ней мы можем обратиться только из того кодового сегмента, в котором содержится её определение (NEAR)
Внутренняя процедура решает поставленную задачу, и команда Ret возвращается на точку возврата,
а второй RET возвращает в ОС.

>Слова, константы, переменные, выражения<
Алфавит - латинские буквы, цифры, некоторые специальные символы
Символическое имя (идентификатор) содержит до 31 символа, начинается с буквы, 
включает буквы и цифры. 
Программа на ассемблере может обрабатывать целые, двоичные, целые-десятичные, целые-двоичные, целые-шестнадцатеричные, действительные с плавающей точкой, символичные, символьные и строковые 
Целые двоичные заканчиваются символом b
А десятичные положительные или отрицательные, и можно записать в конце букву d
Шестнадцатеричные символы заканчиваются символом h, а если 16-ая константа начинается с цифр
'A', 'B', 'C', 'D', 'E', 'F', то перед ней нужно написать 0, иначе воспримет как 
символическое имя

Действительная с плавающей точкой
Например, 34.751е+02 - это 3475.1 или 0.547е-2 - это 0.00547
Строковые данные - заключаются в апострофы или двойные кавычки

Константы могут быть именованными с помощью директивы EQU
Например:
M EQU 27

Переменные в Ассемблере определяются с помощью директивы определения данных и памяти 
v1 DB ?
v2 DW 34
или с помощью директивы '='
v3 = 100
v3 = v3 + 1
Константы в основном используются в директивах определения или как непосредственные
операнды в командах.
Операторы - это знаки операций арифметические, логические, ...

Арифм. '+', '-', '*', '/', mod
Логич. NOT, AND, OR, XOR
Операции отношений LT(<), LE(<=), EQ(=), NE(!=), GT(>), GE(>=)
Операции сдвига: влево (SHL), вправо (SHR)
Специальные операции: offset и PTR
offset с одним операндом, которым может быть символическое имя - метка или переменная, 
а значение операции - адрес, соответствующий этому операнду

Типы операндов у PTR
BYTE(1), WORD(2), DWORD(4), FWORD(6), QWORD(8), TWORD(10)
Или тип вызова: ближний NEAR, FAR - дальний 

Выражение строится из констант, переменных операций и могут использоваться круглые 
скобки для уточнения последовательности вычисления выражения

Директива определения данных и памяти
[<имя>] DX <операнды> <; комментарии>
Операндов может быть несколько, отделяются запятой, операндом может быть знак вопроса или константа
Этой директиве выделяется область в памяти определяемая типом данных и количеством операндов.

И адрес первого байта выделенной области присваивается символическому имени если оно есть 
Если операндом является знак вопроса, то в соотв. область память ничего не записывается,
если константа/выражение, то её значение. 
Например: R1 DB 0, 0, 0; выделено 3 поля заполненных 0
R1 [0]    R1+1 [0]     R1+2 [0]

R2 DB ?, ?, ?
R2 []     R2+1 []      R2+2 []

Если операндом является символическое имя, а этому имени соответствует какое-то значение,
например, смещение в сегменте 03AC1h, то после выполнения
M DD IM1 выделит 4 байта в памяти, а адрес младшего из них присвоит переменная М,
а в эти 4 байта запишет 03AC1h

Если нужно выделить 100 байтов, заполеннные 1, то используется специальный повторитель DUP:
D DB 100 DUP (1) 

Можем определить одномерный массив слов
MAS DW 1, 7, 35, 75, 84

Двумерный массив:
Arr DB  7, 94, 11, -5
    DB  5,  0,  1,  2
    DB -5,  0, 15, 24

Const EQU 100
  D DB Const DUP(?) ; выделить 100 байтов памяти

С помощью директивы определения байта (DB) можно определить строковую константу 
длиной до 255 символов, а с помощью определения слова (DW) можно определить 
строковую константу, которая может содержать не более 2 символов
Но можно сделать так
ST2 DW 'AB', 'CD', 'EF' ; несколько констант

Команда прерывания Int. По команде Int работа процессора приостанавливается, 
и управление передается ОС или BIOS, а после выполнения некоторой системной обрабатывающей
командой управление возвращается следующей за командой Int.
А какая системная обрабатывающая команда будет выполняться зависит от операндов 
в команде Int и от содержимого некоторых строго фиксированных регистров

Например:
Чтобы вывести на экран 1 символ '!'. Необходимо в регистр AH переслать константу 6
В DL символ '!'
А затем команда Int 21 (Процессор передает управление функциям ОС, и должна быть
выполнена функция, номер которой записан в AH). Номер 6 говорит, что нужно вывести на
экран содержимое регистра DL.  

MOV AH, 6
MOV DL, '!'
Int 21h

Стек определяется регистрами SS и SP(ESP). В SS адрес начала сегмента стека, а
SP указывает на вершину стека, и при добавлении элементов в стек значение уменьшается
PUSH <операнд>
POP <операнд>
Операндом может быть регистр или переменная 
Для i186 и >
PUSHA позволяет сохранять содержимое регистров общего назначения в стеке, а POPA удалить,
а для i386 > PUSHAD/POPAD (EAX, EBX, ..., EDI)

К любому элементу стека можно обратиться след. образом
MOV BP, SP
MOV AX, [BP + 6]

Пример программы (след. раз) - переслать содержимое 4 байтов памяти из 1 области памяти 
в другую в обратной последовательности и вывести на экран.