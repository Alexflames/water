................. Надо уточнить начало

Директива условного асс(емблирования?)

1)

if ....
  if-часть
    ....
  else-часть
    ....
2)

if 
  if-часть
elseif 
  elseif-часть1
elseif
  elseif-часть2

if <константное выражение> if-часть

if-часть ассемблируется, включается в исходный текст программы, если значение
выражения - истина, не 0
В противном случае else-часть, если она есть

2) ife <константное выражение>
   elseife <константное выражение>

  if-часть работает, если выражение ложно, равно 0

3) ifdef метка
   elseifdef метка

   if-часть работает, если указанная метка существует (определена)

4) ifndef метка
   elseifndef метка

   if-часть включается, если указанная метка не определена

5) ifb <аргумент>
   elseifb <аргумент>

   Если аргумент - пробел, то if-часть включается в текст программы

6) ifnb <аргумент>
   elseifnb <аргумент>

   Если аргумент - не пробел, то if-часть включается в текст программы

7) ifdif <арг1>, <арг2>
   elseifdif <арг1>, <арг2>

   Если указанные аргументы различные, то if-часть включается
   Прописные и строчные различаются

8) ifdifi <арг1>, <арг2>
   elseifdifi <арг1>, <арг2>

   Если указанные аргументы различные, то if-часть включается
   Прописные и строчные НЕ различаются

9) ifidn <арг1>, <арг2>
   elseifidn <арг1>, <арг2>

   Если указанные аргументы одинаковые, то if-часть включается
   Прописные и строчные различаются

10) ifidni <арг1>, <арг2>
    elseifidni <арг1>, <арг2>

    Если указанные аргументы одинаковые, то if-часть включается
    Прописные и строчные НЕ различаются

  Примеры директивы условной генерации

  Если программа большая, то при отладке программы получается большое
  количество отладочной печати. Когда отладка завершена, отладочные печати
  выбрасываются из текста программы. Если программа долго служит/регулярно
  модифицируется, то отладочные печати нужно то вставлять, то удалять

  Процесс добавления отладочной печати может добавлять ошибки в программе

  Можно использовать директивы условной генерации, определив константу за режим
  работу программы. debug EQU 1 - отладка, debug EQU 0 - счет

  Тогда можно использовать директивы условной генерации следующим образом
    debug EQU 1/0
    mov x, AX
    if debug
      OutInt x
    endif
    mov BX, 0

  После макрогенерации, если debug =/= 0, то в исходном тексте добавится 'OutInt x'
  Здесь OutInt - макрокоманда, организующая вывод

  Директивы условной генерации можно заменить командами условной и безусловной передачи

  mov x, AX
  mov CL, debug
  cmp CL, 1
  jne L
    OutInt x
L:mov BX, 0

  Но директивы условной генерации выполняются на этапе макрогенерации, и в режиме
  debug = 0 те команды не будут в программе

  Опишем макрос, реализующую операцию сдвига переменной x на n разрядов вправо.
  n - явно заданное положительное число. Макрорасширение должно содержать минимально
  возможное число команд. 
    shift macro x, n
          ife n-1
            shr x, 1
          else
            mov CL, n
            shr x, CL
          endif
    endm

    shift A, 5

    После макрогенерации:
      mov CL, n
      shr x, CL

  Формируем текст программы.
  Константное выражение должно быть определено на этапе макрогенерации. 
  Не должно быть никаких величин, определяемых в процессе выполнения программы.
  Регистры/адреса ячеек памяти - НЕТ
  Константное выражение должно быть вычислено макрогенератором при первом проходе.
  Но оно может быть сложным логическим с использованием операции отношения
  EQ, NE, LT, LE, GT, GE и логические операции NOT, OR, XOR.

  Запишем в виде макроса SET_0 x операцию x = 0, если x - переменная размером в
  байт, слово или двойное слово
    SET_0 macro x
      if type x EQ dword
        mov dword ptr x, 0
      elsif type x EQ word
        mov word ptr x, 0
      else mov byte ptr x, 0
      endif
    endm

  Напишем макроопределения для сдвига вправо на n разрядов, учитывая, что
  при n = 0 сдвига нет и макрорасширения нет в тексте
  при n > 7 результат сдвига = 0, сдвиг можно заменить пересылкой нуля

  Макроопределение:
    Set_0 macro B, n
      if (n GT 0) AND (n LT 8)
        mov CL, n
        shr B, CL
      else
        if n GE 8       ;; n >= 8
          mov B, 0
        endif
      endif
    endm

Комментарии начинаются с 2 ;; Они не появятся в тексте проги

Пример 4. Использование ifidn и ifdif
  Найти max и min из двух знаковых величин, хранящихся в регистрах, т.е. R1 = T(R1, R2)
  R1 и R2 - разные регистры. T = min или max

  Max_Min macro R1, R2, T
          local L
          ifdif <R1>, <R2> ;; R1 и R2 - разные регистры
            cmp R1, R2
              ididn <T>, <max> ;; T = max?
                jge L
              else
                jle L
              endif
            mov R1, R2
       L: endif
  endm