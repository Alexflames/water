Команды управления (Продолжение)

1)loop <метка>
2)loope <метка>   loopz <метка>
3)loopne <метка>  loopnz <метка>

1) Из (CX) вычитается 1. Если не ноль, то переход на метку
2) (CX)--. Если ZF = 1, то управление передается на метку (если ZF = 0, то выход)
3) (CX)--. Если (CX <> 0) и ZF = 0, управление передается на метку.

Примеры:
----------
mov CX, 100
m1: mov AX, DX
----------
loop m1
m2:

Регистр CX может использоваться по умолчанию при работе со строками, и CL может использоваться в командах сдвига. 
Если в теле цикла используется регистр CX, то можно использовать вспомогательный регистр

mov SI, 0
mov CX, 100
m1: push CX
----------- (тело цикла)
inc SI
pop CX
loop m1 
m2:

Пример: пусть дана матрица байтовых величин размером 4*5, необходимо подсчитать
количество нулей в каждой строке и заменить их числом OFFh. Под стек отведем 
256 байтов, программу оформим как 2 последовательные процедуры: внешняя(FAR) - 
для связи с ОС, внутренняя (NEAR - решение поставленной задачи.
С помощью стандартных директив сегментации программа может выглядеть так

; prim.asm
title prim.asm ; заголовок каждой страницы листинга
page , 132     ; количество строк (default = 57) и символов в строке (default = 80)
               ; page без параметров переводит на след. страницу листинга
Sseg segment para stack 'stack'
     db 256 dup (?)
Sseg ends
Dseg segment para public 'data'
Dan  db 0,2,5,0,91   ;
     db 4,0,0,15,47  ;
     db 24,15,0,9,55
     db 1,7,12,0,4
Dseg ends
Cseg  segment para public 'code'
      Assume cs:cseg, ds:dseg, ss:sseg
start proc far
      push DS ; для связи с ОС
      push AX ; сохраняем сегмент данных, откуда пришли
      mov BX, Dseg ; загрузка сегмента данных
      mov DS, BX   ; в регистр DS
      call main
      ret     
start endp
main  proc near
      mov BX, offset Dan ; занесли адрес матрицы вместо этой команды можно исп. LEA 
      mov CX, 4 ; количество повторений внешнего цикла
nz1:  push CX
      mov DL, 0 ; счетчик нулей в строке матрицы
      mov SI, 0
      mov CX, 5 ; количество повторений внутреннего цикла
nz2:  push CX   ; кол-во повторений внутреннего цикла
      cmp byte ptr [BX+SI], 0
      jne mz
      mov byte ptr [BX+SI], 0FFh
      inc DL
mz:   inc SI
      pop CX
kz2:  loop nz2
      add DL, '0'
      mov AH, 6  ; вывод на экран кол-во нулей
      int 21h
      add BX, 5  ; переход к следующей строке матрицы
      pop CX
kz1:  loop nz1
      ret
main  endp
Cseg  ends
end start

---------------Массивы в Ассемблере-------------
С помощью директив определения данных, возможно с использованием повторения конструкцией DUP
Например, x DW 30 dup (?) 
Нумерация элементов может быть разной: x[0..29], x[1..30], x[k..29+k]
Удобнее нумеровать с 0 так как 
адрес (x[i]) = x + (type x) * i

Когда первый элемент имеет номер k, то адрес (x[i]) = x + (type x) * (i - k)
Для двумерного массива, пронумерованного с 0 
адрес (A[i,j]) = A + m * (type A) * i + (type A) * j

Для массива слов адрес i-го элемента равен x + 2*i = x + type(x) * i
x - адрес начала массива, 2*i - переменная, определяющая номер элемента массива,
для вычисления индекса (2*i) удобно использовать SI или DI

Для двумерного массива, например, выделение места:
A    DD n DUP (m Dup (?))
     адрес(A[i,j]) = A + m*4*i + 4*j    ; DD - двойные слова, отсюда и 4
Имеем в адресе постоянную часть A и 2 переменные m*4*i и 4*j, их можно хранить в регистрах

Пример:
Фрагмент программы, в регистр AL записывает количество строк байтовой матрицы 10 на 20
в которой первый элемент повторяется хотя бы 1 раз

    mov AL, 0     ; количество искомых строк
    mov CX, 10    ; количество повторений внешнего цикла
    mov BX, 0     ; начало строки 20 * i
m1: push CX   
    mov AH, X[BX] ; первый элемент строки в AH
    mov CX, 19    ; кол-во повторений внутреннего цикла
    mov DI, 0     ; номер элемента в строке (j)
m2: inc DI    ; j = j + 1
    cmp AH, X[BX][DI] ; A[i, 0] = A [i,j]
    loopne m2     ;
    jne L         ; не было в строке равных первому? Тогда переход на L
    inc AL        ; иначе увеличиваем кол-во таких строк
L:  pop CX     ; восстанавливаем содержимое CX
    add BX, 20    ; в BX начало следующей строки
    loop m1

Команды побитовой обработки данных
  Логические команды, сдвига, установки, сброса и инверсии битов

Логические команды
  and, or, xor, not
  Для всех логических команд, кроме not операнды одновременно не могут находиться в памяти, OF = CF = 0, AF - не определен, 
  SF, ZF, PF определяются результатом команды

  and OP1, OP2 ; (OP1) логически умножается на (OP2), результат -> OP1 
  Пример: (AL) = 1011 0011, (DL) = 0000 1111
  and AL, DL ; (AL) = 0000 0011
  Второй операнд называют маской. Она может находиться в команде, в регистре или в памяти, и основное назначение команды AND - установка в 0
  заданных разрядов первого операнда с помощью маски
  Например:
  1) and CX, 0FFh ; маска - константа
  2) and AX, CX   ; маска содержится в регистре
  3) and AX, TOT  ; маска в оперативной памяти по адресу (DS) + TOT
  4) and CX, TOT[BX+SI] ; в ОП по адресу (DS) + (BX) + (SI) + TOT
  5) and TOT[BX+SI], CX ; обнуляются некоторые разряды памяти
  6) and CL, 0Fh ; старшие 4 разряда регистра CL в 0

  or OP1, OP2 ; по аналогии, только прибавляется
  Второй операнд - маска, используемая для установки в единицу заданного разряда первого операнда.
  Могут использоваться различные способы адресации операнда
  Если во всех битах результата 0, то ZF = 1

  Команда xor OP1, OP2 ; 1 xor 1 = 0, 0 xor 0 = 0, в остальных случаях 1
                (AL) = 1011 0011
  xor AL, 0Fh ; (AL) = 1011 1100

  Команда not производит инверсию значения операнда. Не изменяет флаги

  Примеры.
  1) xor AX, AX ; обнуляет регистр AX быстрее чем mov и sub
  2) xor AX, BX ; меняет местами значения AX и BX
     xor BX, AX ; быстрее чем команда xchg AX, BX
  3) Определить количество задолжников в группе из 20 студентов.
  Информация о студентах содержится в массиве байтов
  x DB 20 DUP (?)
  Каждый студент из 0 и 1, где .. - задолжность
  DL - количество задолжников

  mov DL, 0
  mov SI, 0   ; i = 0
  mov CX, 20  ; количество повторений цикла
nz:  mov AL, X[SI]
  and AL, 0Fh ; обнуляем старшую часть байта
  xor AL, 0Fh
  jz m ; ZF = 1, хвостов нет
  inc DL
m: inc SI ; к следующему студенту
  loop nz
  add DL, "0"
  mov AH, 6
  int 21h

Команды сдвига
sXY OP1, OP2

X - h или а (логический или арифм) Y - l или r (влево, вправо)
Второй операнд либо константа, 
либо регистр CL - его младшие разряды со значением [0, 31] 

shl ; логический влево
sal ; арифм влево, ничем не отличается от shl
shr отличается от sar тем что заполняет освобождаемый разряд знаковым разрядом

Сдвиги повышенной точности 
shrd OP1, OP2, OP3 ; сдвиг OP1 на OP3, если вышел за границу, то биты в OP2

Циклические сдвиги
rol op1, op2 ; бит если попал за конец, то в начало
ror op1, op2 

; как цикл, только помещаются в CF, а затем уже оттуда на начало
rcr OP1, OP2 
rcl OP1, OP2

ZF, SF, PF в зависимости от результата операции, AF не определен, OF не определен на сдвиге в несколько разрядов
В зависимости от команды OF принимает свое значение

НА САМОСТОЯТЕЛЬНОЕ ИЗУЧЕНИЯ, ТАКЖЕ ДОП.БАЛЛЫ ВОЗМОЖНЫ
Команды установки, сброса и инверсии разрядов
BT <приемник>, <источник>
BTS <приемник>, <источник>
BTR <приемник>, <источник>
BTC <приемник>, <источник>
BSF <приемник>, <источник>
BSR <приемник>, <источник>


----------Структуры в ассемблере-----------
Сложные данные, объединяющие данные различного типа и длины.
Для того чтобы использовать переменную структурного типа нужно сначала
описать идентификатор типа структуры, а затем переменную такого типа.
Тип структуры описывается:
  <имя типа> struc
    <описание поля>
    ---------------
    <описание поля>
  <имя типа> ends

<имя типа> - идентификатор типа структуры, struc и ends - директивы

Для описания полей используются директивы описания данных и памяти, но 
имена полей структур уникальные в рамках всей программы

Вложенные структуры в ассемблере не допускаются
Например, 
TData struc
  y DW 2000  ; y, m, d - имена полей
  m DB ?     ; значения - значения полей, 
  d DB 28    ; принятых по умолчанию
TData ends

На основании типа структуры место в памяти не выделяется
Но при описании переменной такого типа место в памяти выделяется в 
соответствии с описанием типа
В данном примере 
|-------------------|
|      2б   1б   1б |
|-------------------|
|TData y    m    d  |
|-------------------|
|      +0   +2   +3 |
|-------------------|

dt1 TData <?, 6, 4> ; начальное значение
dt2 TData <1999, , > ; начальное значение
dt3 TData < , , > ; начальное значение
Начальным значением может быть 1) ? 2) выражение 3) строка 4) пусто
Пусто - выбирается значение по умолчанию. Начальное значение, очевидно, имеет приоритет

Если нач. значение не помещается в поле, отведенное при описании типа структуры, то выводится сообщение об ошибке