Значения по умолчанию обычно указываются для тех полей, которые являются общими
для многих переменных. Например, год поступления в университет.
Так как поля могут изменять свои значения в процессе выполнения программы, то 
могут отсутствовать и начальные значения, и значения по умолчанию.
При этом если отсутствует начальное значение нескольких последних полей, то можно
не указывать и запятые, отделяющие их.
  dt4 TData<1980, , > эквивалентно dt4 TData<1980>
Если отсутствуют все начальные значения, то можно не писать запятые, 
но угловые скобки должны остаться dt6 TData <>
Можно писать отдельную переменную многократно, а можно писать массив структур 
с помощью повторителя DUP. 
  dst TData <, 4, 1>, 25 DUP (<>)   ; первый элемент имеет начальное значение
                                    ; остальные 25 по умолчанию
Первый элемент структуры dst, второй - dst+4, третий - dst+8
Обращаться к полям структуры можно как и в языках высокого уровня, через точку
<имя переменной>.<имя поля>
  dt1.y, dt2.m, dt3.d
В отличии от языков высокого уровня Ассемблер приписывает имени типа и имени 
переменной размер(тип), равный количеству байт занимаемых этой переменной
  type TData = type dt1 = 4
Эту конструкцию можно использовать при работе со структурой.
Пример: выполним побайтовую пересылку из dt1 в dt2.
  mov CX, type TData ; кол-во повторений
  mov SI, 0 ; i = 0
  m:
    mov AL, byte ptr dt1[SI]
    mov byte ptr dt2[SI], AL
    inc SI
  loop m

Точка - оператор, вычисляющая <адрес выражения> + <смещение поля> в структуре
Тогда тип полученного адреса совпадает с типом поля, т.е.
  type (dt1.m) = type m = byte 
Адресное выражение может быть любой сложности в зависимости от способа адресации
  1) mov AX, (dst+8).y
  2) mov SI, 8
     inc (dst[SI]).m ; исп.адрес = (dts + [SI]).m = (dts + 8).m
  3) lea BX, dt1
     mov [BX].d, 10  ; исп.адрес = (BX) + d = dt1.d

Замечания:
  1) type (dst[SI]).m = type (dst[SI].m) = 1
     type dst[SI].m = type dst = 4
Вверху размер поля, внизу размер структуры
  2) Если при описания типа структуры в директиве, которая описывает значение 
     по умолчанию некоторого поля содержится несколько операндов или конструкция
     повторения DUP, то при описании переменной такого типа это поле не может
     иметь начального значения и не может иметь в качестве начального значеняи (?)
     Но:
     Если в качестве значения по умолчанию используется строка, то в качестве 
     начального значения это поле тоже может иметь строку меньшей или равной длины
       student struc
         f DB 10 DUP (?)
         i DB "*******"
         gr DW ?
         oz DB 5, 5, 5
        student ends

        st1 student <"Petrov", > ; нельзя, f - не строка
        st2 student < , "Petr", 112, > ; можно
        st3 student < , "Aleksandra">  ; символов больше чем значение по умолчанию

        .model tiny
        .code
        org 100h
Start:  mov AH, 9
        mov DX, offset message
        int 21h

        lea DX, st1.s
        int 21h
        lea DX, st1.f
        int 21h
        lea DX, st1.i
        int 21h
        ret

        message DB "hello", 0dh, 0ah, "$"
        tst struc
          s DB "student", "$"
          f DB "Ivanov ", "$"
          i DB "Ivan   ", "$"
        tst ends
        st1 tst < > ; значения по умолчанию 
      end start

    Пример 2: обращение к полям структуры в цикле
        .model tiny
        .code
        org 100h
Start:  mov AH, 9
        mov DX, offset message
        int 21h

        mov SI, 0
        mov CX, 3
m1:       lea DX, st1[SI]
          int 21h
          add SI, 9
          loop m1
        ret

        message DB "hello", 0dh, 0ah, "$"
        tst struc
          s DB "student", "$"
          f DB "Ivanov ", "$"
          i DB "Ivan   ", "$"
        tst ends
        st1 tst < >
        end start

      Пример 3: обращение к полям структур: цикл в цикле.
        .model tiny
        .code
        org 100h
Start:  mov AH, 9
        mov DX, offset message
        int 21h

        lea BX, st1
        mov CX, 2
m2:       push CX
          mov SI, 0
          mov CX, 3
m1:         push CX
            lea DX, [BX][SI] ; по базе с индексированием
            int 21h
            add SI, 9
            pop CX
            loop m1
          add BX, type tst
          pop CX
          loop m2
        ret
        
        message DB "hello", 0dh, 0ah, "$"
        tst struc
          s DB ?
          f DB ?
          i DB ?
        tst ends

        st1 tst <"student $","Ivanov $", "Ivan,   $"
        st2 tst <"student $","Petrov $", "Petr,   $"
        end start

        Результат: 
          hello
          student Ivanov Ivan, student Petrov Petr

Записи в Ассемблере
Упакованные данные, которые занимают не отдельные ячейки-байты, а последовательности битов.
При этом размер записи может быть равен 1 или 2 байтам (байт или слово).
У записи может быть произвольное количество полей, но размер не должен превышать байт или слово.
Поля записи прижаты к правой границе байта/слова. Лишние левые разряды заполняются нулями, но не используются и не влияют на работу программы. 
Поля прижаты друг к другу. Поля записи так же как и в структуре имеют свои имена, 
но напрямую к полям записи обращаться нельзя.
Имена полей записи должны быть уникальны внутри всей программы
Для работы с полями записи имеются средства.  
Как и у структуры, сначала тип записи, а затем переменные этого типа.

Описание типа запись:
  <имя типа записи> record <поле> {, <поле>} ; через запятую возможны поля
  <поле> :: <имя поля> : <размер> [= <выражение>]
    Выражение - константные выражения
    Размер - размер поля в битах
    Выражение - значение поля по умолчанию (в отличие от структуры не может быть (?))
  Например:
    TRec record A : 3, B : 3 = 7
    TData record Y : 7, M : 4, D : 5
  Прим:  Y (год) 2^6 < Ymax < 99 < 2^7

  Приоритетны начальные значения. Если отсутствует, то по умолчанию 0.
  Объявление: имя записи  имя типа записи  <начальное значение> 
  Угловые скобки обязательны, а начальными значениями могут быть 
    1) константное выражение, 2) знак ? (эквивалентно 0), 3) пусто

  Rec1 TRec <3, >
  Rec2 TRec < , ?>
  Dat1 TData <80, 7, 4> 

  Запятые также как в структурах.
  Массивы записей:
    MDat TData 100 Dup (< >)

  Как работать с ними:
    mov AL, Rec2
    mov Rec1, AL

  Для работы с отдельными полями записи существуют операторы width и mask
    width <имя поля записи>
    width <имя записи или имя типа записи>
    Значение - размер в битах поля или всей записи в зависимости от операнда.

    mask <имя поля записи>
    mask <имя записи или имя типа записи>
    Результат работы оператора - маска (байт или слово в зависимости от размера записи), которое содержит единицы в тех разрядах, которые занимает операнд

    mask A = 00111000b
    mask B = 00000111b
    mask Y = 111111100000000b
    mask Rec1 = mask TRec = 00111111b

    Пример использования:
    Выявить родившегося первого числа, выделяя поле D сравнивать значение с 1

    m1: ------------
        mov AX, Dat1
        and AX, mask D
        cmp AX, 1
        je yes
    no: -------------
        -------------
        jmp m1
   yes: -------------

Подпрограммы в Ассемблере
  Основная программа оформляется как процедура дальнего вызова 
  так как с ней работаем из отладчика ОС

  <имя процедуры> proc <параметр>
                       <тело процедуры>
                  ret
  <имя процедуры> endp

  Размещать описание процедуры можно в любом месте но так чтобы случайно не попадало
  на неё управление. Если подпрограм несколько, то их размещают перед основной
  программой или после исполняемой программы. А если подпрограмм очень много, то
  их можно объединять в отдельный кодовый сегмент, и тогда структура программы
  с использованием подпрограмм можно представлять следующим образом: 
  1) cseg segment ...
  beg: -----------------
       -----------------
       -----------------
       -----------------
  fin: -----------------
  <подпрограмма 1>
  <подпрограмма 2>
  -----------------
  <подпрограмма N>
  cseg ends
  end beg

  2) cseg segment
  <подпрограмма 1>
  <подпрограмма 2>
  -----------------
  <подпрограмма N>
  beg: -----------------
       -----------------
       -----------------
       -----------------
  fin: -----------------
  cseg ends
  end beg

  3) cseg_pp segment
  <подпрограмма 1>
  <подпрограмма 2>
  -----------------
  <подпрограмма N>
  cseg_pp ends 

  ; Они все ^^^ far

  cseg segment

  ;main

  cseg ends 

  1)После имени proc и endp двоеточие не ставится, имя считается меткой, адресом
  первой исполняемой команды процедуры. 
  2)Метки не локализованы, они уникальны в рамках всей программы
  3)Параметр NEAR или FAR

  Передача параметров. Существуют различные способы. 
  1) По значению      3) по возвращаемому значению
  2) По адресу/по ссылке 4) по результату 5) отложенным вычислениям

  Параметры могут находиться - их можно передавать через
  1) Регистры     3) Стек   4) Поток кода
  2) глобальные переменные  5) блок параметров

  Самая простая - через регистры. Вызывающая программа записывает значение параметра
  в некоторые регистры, подпрограмма оттуда извлекает, использует, 
  возможно, записывает в них результаты. Функции DOS, BIOS используют это.

  Если регистров не хватает (их мало), можно записать фактические параметры
  в глобальных переменных в сегменте данных (вариант нехорош!), может произойти
  невозможная рекурсия / повторное возвращение к подпрограмме

  Универсальное - передача параметров через стек. Вызывающая программа записывает
  параметры в стек - значения и адреса. Подпрограмма вызывает из стека, а возвращает
  через регистры или любым другим способом. Именно через стек в языках высок. уровня.

  Передача в потоке кода - "интересно"))
  Параметры располагаются сразу за командой call, а подпрограмма чтобы извлечь эти
  параметры должна использовать адрес в стеке, 
  в который записываются в стеке автоматически с помощью call как адрес возврата
  Прежде чем выйти из подпрограммы (перед ret) необходимо изменить адрес возврата.
  Медленней чем через регистры/стек, также как в блоке параметров.

  Блок параметров - участок в оперативной памяти в сегменте данных.
  Процедура получает адрес этого блока параметров любым способом, через
  регистры, стек, другой блок параметров (используют некоторые функции DOS и BIOS)
  Например, поиск файлов.

