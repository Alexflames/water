[Передача параметров по значению] предполагает, что подпрограмме передается
значение фактического параметра, в подпрограмме делается копия этого параметра,
используется так чтобы изменить было значение невозможно

Например: c = max(a,b) + max(7, a-1)
Все числа знаковые, размером в слово. Будем использовать передачу параметров 
через регистры. Процедура будет получать в регистры AX, BX фактические параметры,
и результат сохраняет в AX.

Процедура: AX = max(AX, BX)

max proc
    cmp AX, BX
    jge met1
    mov AX, BX
  met1:
    ret
max endp

Обращение к этой программе
-------------------------------
mov AX, a
mov BX, b
call max
mov c, AX ; c = max(a, b)
mov AX, 7
mov BX, a
dec BX
call max  ; AX = max(7, a - 1)
add c, AX
-------------------------------

[По адресу] когда входной параметр должен быть и выходным. 
Оформим процедуру x = x div 16
Для параметров a и b нужно передать их адреса
Передавать параметры можем любым способом. Пока задачи простые, используем регистры.
Чаще всего используют BX, BP, SI, DI

Пусть передаем адрес параметра через регистр BX
Тогда получится следующий фрагмент проги:
----------------------------------
|lea BX, a                       |
|call Proc_dv                    |
|lea BX, b                       |
|call Proc_dv                    |
----------------------------------

Сама процедура:
Proc_dv proc
  push CX
  mov CL, 4
  shr word ptr [BX], CL ; x = x div 16
  pop CX
  ret
Proc_dv endp

Поскольку регистров немного, одни и те же регистры используются в вызывающей 
программе и подпрограмме, то обычно при переходе в подпрограмму сохраняют в стеке
значения регистров, которые будут использоваться в подпрограмме, а перед выходом
из подпрограммы их восстанавливают.
pusha и popa для 16-разрядных, pushad и popad для 32-разрядных
Сохраняют в стеке значения всех регистров общего назначения

[Передача параметров в блоке параметров] (Работа с массивом - блоком параметров)
 Обычно делается по адресу, и адрес начала
массива можно пересылать через регистры.

Дано:
  X DB 100 dup (?)
  Y DB  50 dup (?)

Выичлить DL = max(X[i]) + max(Y[i]) -- максимальные элементы этих массивов
Адрес через BX, результат в AL

Создадим процедуру поиска максимума в одномерном массиве
--------------------------------------------------------
  lea BX, X
  mov CX, 100
  call max    ; AL = max (X[i])
  mov DL, AL  
  lea BX, Y
  mov CX, 50
  call max    ; AL = max (Y[i])
  add DL, AL  
--------------------------------------------------------

AL = max (A[0..n-1]), BX - начальный адрес, CX = n.

max proc
      push CX
      push BX
      mov AL, 0   ; начальное значение max
met1: cmp [BX], AL
      jle met2
      mov AL, [BX]
met2: inc BX
      loop met1
      pop BX
      pop CX
      ret
max endp

[Передача параметров через стек]
Универсальный, для любого количества параметров.

Если ПП имеет k параметров PP(a1, a2, ..., ak) размеров в слово и параметры сохраняются в стеке в последовательности слева направо
      
                    push a1      SP | av |
                    push a2         | ak |
                    -------         -----|
                    push ak         | a2 |
                    call PP         | a1 |
av(адрес возврата): -------      SS ------

Обращаемся к параметру с помощью регистра BP. 
Для этого в него нужно переслать значение SP.
Кроме того, при входе в подпрограмму регистры BP использовался для каких-либо целей,
и при выходе из подпрограммы это значение возможно понадобится, следовательно, 
входными действиями процедуры должны быть следующие команды: 

PP proc near          в стеке после выполнения этих команд
   push BP                    SP, BP -> |BPстар|
   mov BP, SP                     +2    |  av  |
                                  +4    |  ak  |
                                        | ---- |
                                        |  a1  |
                                        | ---- |
Выходные действия:

   pop BP   ; восстановить старое значение BP
   ret 2*k  ; очистка стека от k параметров
PP endp

Команда ret вначале считывает адрес возврата, 
                                  а затем удаляет из стека фактические параметры

Можно освободить стек после команды call, например, add SP, 2 * k

Если фактических параметров много, то чтобы облегчить работу с параметрами можно
использовать директиву EQU. Чтобы при каждом не писать точное значение BP.

push x
push y
push z
call PP
-------

PP proc near
  push BP
  mov BP, SP
  pp_x equ [BP + 8]
  pp_y equ [BP + 6]
  pp_z equ [BP + 4]
  -------------
    mov AX, pp_x    ; использование параметра x
  -------------
  pop BP
  ret 6
pp endp

Пусть процедура заполняет нулями массив А[0..n - 1]
Через стек передается имя массива и его размер, размер по значению, имя по ссылке.

zero_1 proc
       push BP
       mov BP, SP
       push BX
       push CX
       mov CX, [BP + 4]
       mov BX, [BP + 6]
m1:      mov byte ptr [BX], 0
         inc BX
         loop m1
       pop CX
       pop BX
       pop BP
       ret 4
zero_1 endp

Фрагмент основной проги:

  X DB 100 dup (?)
  Y DB  50 dup (?)
-------------------
  lea AX, X
  push AX       ; загружаем адрес массива X
  mov AX, 100   ; и его размер
  push AX       ; в стек
  call zero_1
  lea AX, Y     ; то же, только для Y
  push AX
  mov AX, 50
  push AX
  call zero_1

Передаче параметров ПП (в общем виде)
1. По значению:
  mov AX, word ptr value
  call PP
2. По ссылке:
  mov AX, offset value
  call PP
3. Передача параметров по возвращаемым значениям. Объединение передачи по значению и по ссылке. Подпрограмме передается адрес параметра, 
подпрограмма делает копию этого параметра, и работает с этой копией, а в конце 
процедуры записывает эту копию по переданному адресу. 
4. Это говорит о том, что мы передаем адрес только для записи результата
#Meme! А следующие 2 "интересные"
5. Передача параметров по имени макроопределения. Пример:
  name macro parametr
    mov AX, parametr
  name endm
Обращение к ПП может быть таким:
  name value
  call PP

6. Передача параметров отложенным вычислениям. Как и в случае передачи параметров
по имени макроса, процедура получает адрес ПП, который вычисляет параметр. 
Этот механизм используется в системах ИИ и в ОС

[Использование локальных параметров].
Локальные параметры имеют смысл только для использующей их подпрограммы. 
Если их мало, то хранят в регистре, много - в стеке.

Перед реализацией ПП нужно выделить место в стеке, а перед выходом из ПП нужно
освобождать стек и от локальных, и от фактических параметров. 
Работаем с локальными так же как и с фактическими с помощью регистра BP. 
[BP - n], где n - смещение локального параметра относительно значения BP

SP ----> Lz                 Входные действия в подпрограмму
BP - 4 | Ly |  
BP - 2 | Lx |               PP proc
    BP |BPст|                 push BP      ; сохранить старое значение BP
BP + 2 | av |                 mov BP, SP
BP + 4 | ak |                 sup SP, k1   ; освобождаем в стеке k1 байтов под лок.
       | -- |                 push AX      ; 
       | a1 |                 --------
       | -- |                 <тело процедуры>
    SS |    |                 --------
       ------                 pop AX
                              mov SP, BP   ; восстановили SP, освободили от лок.пар. 
                              pop BP 
                              ret k2       ; освобождаем стек от фактических
                            PP endp

Посчитать количество различных символов в заданной строке. 
  Строка задана как массив символов. Начальный адрес передаем в ПП через
  регистр BX, длину строки через CX, а результат - через AX. 
  Отведем 256 байтов под локальный массив L по количеству возможных символов.
  k-ому элементу массива будем присваивать 1 если символ, цифровой код которого
  равен k в этой строке содержится. Затем посчитаем количество единиц в массиве

  Обращение к первому элементу: L1 = [BP - 256], к K-ому Lk = [BP - 256 + k]
  Count_s proc
    push BP
    mov BP, SP
    sub SP, 256
    push BX
    push CX
    push SI
    ; обнуление локального массива
    mov AX, CX  ; сохранение длины исходной строки
    mov CX, 256 ; возможное количество символов
    mov SI, 0   ; индекс эл-та
m1:   mov byte ptr [BP - 256 + SI], 0
      inc SI
      loop m1
    ; просмотр заданной строки и запись 1 в локальный массив
    mov CX, AX ; длину строки в CX
    mov AX, 0  
m2:   mov AL, [BX]
      mov SI, AX
      mov byte ptr [BP - 256 + SI], 1
      inc BX
      loop m2
    ; подсчитаем единицы в массиве
    mov AX, 0
    mov CX, 256
    mov SI, 0
m3: cmp byte ptr [BP - 256 + SI], 1
    jne m4
    inc AX
m4: inc SI
    loop m3
    ; выходные действия
    pop SI ; в обратной
    pop CX ; последовательности
    pop BX ; восстанавливаем регистры
    mov SP, BP
    pop BP
    ret
count_s endp