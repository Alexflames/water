Лекция 4.
Стандартные директивы сегментации. Пересылка содержимого 4 байтов памяти из 1 области памяти в другую и вывести на экран.

TITLE Prim.asm
Page , 120      ;пробел означает, что 1 параметра нет

SSeg Segment Para stack 'stack'
  DB 100h DUP (?)
SSeg ends
DSeg Segment Para Public 'Data' ; определяем исходные данные
  DAN DB '1', '3', '5', '7'
  REZ DB 4 DUP (?)
DSeg ends
; Кодовый сегмент будет одной внешней процедурой, к которой будем 
; обращаться из отладчика
CSeg Segment Para Public 'Code'
  ASSUME SS:SSeg, DS:DSeg, CS:CSeg
  Start Proc FAR
    PUSH DS
    XOR AX, AX
    PUSH AX
    MOV AX, DSeg
    MOV DS, AX
; В процессе компиляции символическому имени DSeg присвоено значение - адрес, и мы этот адрес пересылаем в DS
    MOV AH, 6 ; номер функции операционной системы, определяющей
              ; необходимость вывести содержимое DL на экран
    MOV DL, DAN + 3 ; символ '7'
    MOV REZ, DL     ; '7' '5' '3' '1'
    Int 21h ; '7'
    MOV DL, DAN + 2 ; '5'
    MOV REZ + 1, DL 
    Int 21h ; '5'
    MOV DL, DAN + 1; '3'
    MOV REZ + 2, DL
    Int 21h
    MOV DL, DAN
    MOV REZ + 3, DL
    Int 21h
;
    MOV AH, 4CH
    Int 21h
  Start endp
CSeg ends
end Start

Директива TITLE определяет заголовок каждой страницы листинга программы
(Может содержать до 60 символов) Если первые 6 символов удовлетворяют требованиям идентификатора (симв. имени Ассемблера) и в проге нет NAME, может восприниматься как имя модуля

Директива PAGE в общем случае с 2 параметрами определяет количество строк на странице листинга. Первого параметра нет - по умолчанию 50
Второй параметр - количество символов в строке (по умолчанию 80) до 132
Эта директива может использоваться без параметров (осуществляет переход на след. страницу листинга)

Директива Segment
<имя> Segment <ReadOnly> <выравнивание> <тип> <размер> <'класс'>
Каждый из этих параметров может отсутствовать
1) Если есть <ReadOnly>, то будет сообщение об ошибке при попытке записи информации в сегмент
2) Выравнивание - адрес, с которого может начинаться сегмент
*Byte - адрес начала сегмента любой
*Word - кратен 2
*DWORD - кратен 4
*Para - кратен 16
*Page - кратен 256
3) <тип> определяет как могут объединяться сегменты
*stack для сегмента стека
Для остальныхх *public. Если такой параметр присутствует, то все сегменты с 1 именем и различными классами объединяются в 1 в порядке их записи
*Common - сегменты с одинаковыми именами тоже объединяются, но не последовательно, а с одного и того же адреса, так что размер памяти выделенный под эти сегменты будет не суммой размеров сегмента, а равен максимальному из них
Значение IT <выражение> говорит, что сегмент должен располагаться в памяти по точно указанному адресу равному значению выражения.
*Private - сегмент ни с какими другими не объединяется
4) <разрядность> use 16 - до 64 Кб
                 use 32 - до 4 ГБ
5) <'класс'> сегменты с одинаковым классом располагаются в исходном модуле в порядке их написания в исходном модуле.

Это были директивы стандартной сегментации.  
Ассемблер предоставляет пользователю упрощенные директивы сегментации  (точечные, начинаются с точки)

В этом случае первой директивой в программе должна быть .MODEL
Определяет размер памяти, выделяемый под всю программу
1 параметр:
*tiny - под программу 1 сегент памяти  *small - под данные и подпрограмму по 1 сегменту  *medium - под данные 1 сегмент, под подпрограмму несколько  *compact - под данные несколько, под подпрограмму 1  *large - под данные и под программу по n сегментов  *huge - позволяет временно записывать сегменты на внешние носители

Пример проги:
.MODEL small
.STACK 100h
.DATA
  St1  DB 'Line1', '$'
  St2  DB 'Line2', '$'
  St3  DB 'Line3', '$'
.CODE
begin: MOV AH, 9  
  ; 9 - функция вывода строки на экран, адрес которой содержится в DX 
  MOV DX, offset St1
  Int 21h
  MOV DX, offset St2
  Int 21h
  MOV DX, offset St3
  Int 21h
  MOV AH, 4CH
  Int 21h
end begin

'$' - признак конца выводимой строки. Результат программы:
Line1Line2Line3

Чтобы вывести в столбец нужно внести изменения в сегмент данных, а именно дополнить каждую строку символом перевода строки и возврата каретки(?)
  St1  DB 'Line1', 13, 10, '$'
  St2  DB 'Line2', 0Dh, 0Ah, '$'
  St3  DB 'Line3', '$'

|=========|
|COM-файлы|
|=========|
После ассемблирования и редактирования мы получаем исполняемый .exe файл, который содержит блок начальной загрузки, размером не менее 512 байт, но существует возможность создания исполняемого .com файла на основе .exe файла с помощью системно-обрабатывающей программы exe2bin.com или в среде разработки с установки определенных ключей обработки. Но не из всякого .exe файла можно сделать .com файл. 
.com не содержит блок начальной загрузки, и следовательно в любом случае меньше чем .exe файл
У .com нет блока начальной загрузки

Но чтобы получить .com файл, нужно, чтобы исходный модуль удовлетворял определенным требованиям. 
1) занимает только 1 сегмент памяти, в котором содержится и программа, и все данные
Для .com файла стек определяется автоматически (не нужно выделять место)
2)Поскольку и программа, и данные содержатся в 1 сегменте, то после процесса ассемблирования и редактирования все сегментные регистры в качестве адреса содержат адрес блока PSP, который есть и у .exe файла и у .com, - блок размером 256 байтов (некоторая системная информация), адрес первой исполняемой команды отстоит от начала сегмента на 256 байтов
Поэтому этот блок нужно обойти, и для этого после ASSUME должна располагаться директива Org 100h, которая этот обход и реализует.

Пример исходного файла из которого можно сделать .com

1) 
TITLE Prog_Com-файл
Page 60, 85
CSeg Segment Para 'Code'
ASSUME SS:CSeg, DS:CSeg, CS:CSeg
Org 100h
Start: JMP Main
  St1 DB 'String1', 13, 10, '$'
  St2 DB 'String2', '$'
  ;
  Main Proc
    MOV AH, 9
    LEA DX, St1
    Int 21h
    LEA DX, St2
    Int21h
    MOV AH, 4CH
    Int 21h
  Main endp
CSeg ends
end Start

2) То же самое с точечными директивами
.Model tiny
.Code
JMP Met
St1 DB 'String1', '$'
Met: MOV AH, 09h
     LEA DX, St1
     Int 21h
     MOV AH, 4Ch
     Int21h
end Met

3) Данные можно записывать как в начале, так и в конце. Если в начале, то надо обходить, а иначе можно..

............
Beg Proc
  MOV AH, 9
  LEA DX, St1
  Int 21h
  MOV AH, 4Ch
  Int 21h
Beg endp
St1 DB 'String1', '$'
end Beg

Замечания:
  Файл созданный как .com не может быть выполнен как .exe
  Маленькие программы рекомендуется оформлять как .com - файлы

|=======================|
|Арифметические операции|
|=======================|
Для беззнаковых чисел выполняются по правилам: по модулю 2^k
Лишние байты не отбрасываются, а пересылаются в регистр CF

X + Y = (X + Y) mod 2^k = X + Y и CF = 0, если X + Y < 2^k
X + Y = (X + Y) mod 2^k = X + Y - 2^k и CF = 1, если X + Y >= 2^k

Пример, работая с байтами получим
250 + 10 = (250 + 10) mod 2^8 = 260 mod 256 = 4
260 = 1 0000 01000, CF = 1, результат 0000 01000 = 4

X - Y = (X - Y) mod 2^k = X - Y и CF = 0, если X >= Y
X - Y = (X - Y) mod 2^k = X + 2^k - Y и CF = 1, если X < Y

Пример: в байте
1 - 2 = 2^8 + 1 - 2 = 257 - 2 = 255, CF = 1

Сложение и вычитание знаковых чисел сводится к сложению/вычитанию чисел с использованием дополнительного кода
X = 10^n - |X|

На примере:
-1 = 256 - 1 = 255 = 11111111
-3 = 256 - 3 = 253 = 11111101

3 + (-1) = (3 + (-1)) mod 256 = (3 + 255) mod 256 = 2
1 + (-3) = (1 + (-3)) mod 256 = 254 = 11111110  (дополнительный код)
X = 10^n - |X| = 256 - 254 = |2| и знак минус. Ответ: -2

Если при выполнении операции (сложение/вычитание) происходит перенос из старшего цифрового в знаковый, а из знакового переноса нет и наоборот, тогда флажок OF становится 1

Все арифметические команды изменяют значения флажков OF, CF, SF, ZF, AF, PF

Команды Ассемблера
ADD OP1, OP2 ; (OP1) + (OP2) -> OP1
ADC OP1, OP2 ; (OP1) + (OP2) + (CF) -> OP1
XADD OP1, OP2 ; меняет местами и посылает результат суммы в (OP1)
INC OP1 ; (OP1) + 1 -> OP1

SUB OP1, OP2
SBB OP1, OP2 ; (OP1) - (OP2) - (CF) -> OP1
DEC OP1      ; (OP1) - 1 -> OP1

Можно работать с большими данными
Пусть X = 1234AB12h
      Y = 5678CD34h

X + Y =
  MOV AX, 1234h
  MOV BX, 0AB12h
  MOV CX, 5678h
  MOV DX, 0CD34h
  ADD BX, DX
  ADC AX, CX

X - Y =
  ....
  SUB BX, DX
  SBB AX, CX

В командах сложения и вычитания можно использовать любые способы адресации:
  ADD AX, mas[SI]     ; индексированная
  SUB DX, mas[BX][DI] ; адресация по базе с индексированием
  ADD CX, 32h         ; непосредственная адресация

Пример №1
Пример №2

MOV AL, 9h
SUB AL, 5h