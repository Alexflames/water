Умножение беззнаковых чисел
MUL OP2 ; (OP2) * (AL) v (AX) v (EAX) -> AX v DX:AX v EDX:EAX
Умножение в зависимости от типа операнда ^^
При умножении чисел результат может занимать формат удвоенный по сравнению со множителями

Для знаковых 
IMUL OP2
IMUL OP1, OP2 ; 1 операнд - регистр, а второй - непосредственный регистр
              ; или память
IMUL OP1, OP2, OP3 ; результат в OP3

Результат может иметь удвоенный формат, но бывают случаи, когда прогер знает, что результат умещается в размер сомножителей, тогда его можно извлекать из AL, AX или EAX соответственно. Если не знаем зарнее, то можно узнать по значению флажков OF(переполнение), CF(сдвиг)
Если OF = CF = 1, то результат удвоенный
     OF = CF = 0, то результат умещается в формат сомножителя
Другие флажки не меняются

Деление беззнаковых чисел
DIV OP2

Знаковых
IDIV OP2 ; OP2 - регистр или память
         ; Содержимое регистра (AX) v (DX:AX) v (EDX:EAX) делятся на
         ; значение операнда, целая часть -> AL v AX v EAX
         ; остаток помещается в регистры  -> AH v DX v EDX
         ; в зависимости от типа операнда 
Не меняет флажков, но может быть ошибка деления на 0 или результат не умещается в отведенное ему место (переполнение), если операнд равен 0 или полученный результат не умещается в отведенное ему место.
MOV AX, 600
MOV BH, 2
DIV BH ; 600 div 2 = 300 - не умещается в AL

При выполнении арифметических операций нужно следить за разрядностью операндов и при необходимости расширять значения.

Пример: выделить цифры целого беззнакового числа N и записать их как символы начиная с адреса D. Можно их получить таким образом
  c = N mod 10
  b = N div 10 mod 10
  a = N div 10 div 10 
  Перевод в символы: код(i) = код('0') + i

  Фрагмент программы может выглядеть след.образом
    .....
    N DB ?
    D DB 3 Dup (?)
    .....
    MOV BL, 10
    MOV AL, N
    MOV AH, 0 ; или CBW AH -> конвертируем до слова
    DIV BL ; AL = ab, AH = c
    ADD AH, '0'
    MOV D+2, AH
    MOV AH, 0
    DIV BL  ; AL = a, AH = b
    ADD AL, '0'
    MOV D, AL
    ADD AH, '0'
    MOV D+1, AH
    .....

|=========================|
|Директивы внешних ссылок. 
В ассемблере есть возможность организовать связь между отдельными модулями и файлами на диске. Для этого существуют спец. директивы. 
Public <имя> [, <имя>, <имя>, ...]
Определяет указанные через запятую имена как глобальные, доступные из других модулей. Ими может быть метка или переменная определенная с помощью '=' или EQU. 
Если некот. имя определено в модуле А как глобальное, и к нему нужно обратиться из других модулей B и C, то в этих модулях должна быть директива вида
  EXTRN <имя>:<тип> [,<имя>:<тип>, ...]
Имя то же, что и в Public, а тип для имени переменной: 
  BYTE, WORD, DWORD, FWORD, QWORD, TWORD.
Если имя - метка, то тип NEAR или FAR, т.е. директива EXTRN говорит, что перечисленные им имена являются внешними по отношению к данному модулю.
  Если в A есть Public TOT, а TOT DW 0

  То из B и C чтобы обратиться, то в них должна быть директива EXTRN TOT:WORD

В Ассемблере существует возможность подключения к программе на этапе ассемблирования файла, расположенного на диске
  INCLUDE <имя файла>
Например, INCLUDE C:\WORK\Prim.ASM на этапе ассемблирования на месте этой директивы запишется содержимое этого файла.

Команды управления предназначены для того чтобы изменить направление вычислительного процесса. 
К ним относятся:
1)Команды безусловной передачи управления
2)Условной передачи управления
3)Команды организации циклов

1) JMP <имя> - передает управление на команду с указанной меткой
Причем команда с указанной меткой может располагаться в этом же сегменте, а может распологаться в другом кодовом сегменте

Например, JMP M1 - значит, что команда M1 находится в этом же кодовом сегменте. То есть метка M1 по умолчанию считается ближней меткой типа NEAR. 
А если в другом кодовом сегменте, то в том сегменте куда передаем управление должна быть директива Public M1, а в сегменте из которого передаем EXTRN M1: FAR

Передача может быть реализована с помощью
*прямой адресации    - JMP M1
*косвенной адресации - JMP [BX]
Значит в BX должен содержаться адрес команды на которую нужно передать управление
JMP часто используется в ассемблере, поэтому команда безусловной передачи на близкую метку занимает 3 байта, на дальнюю - 5 байтов памяти

Если передаем управление на не далее чем -128 или 127 байтов, то можно использовать вариант команды, занимающий 1 байт памяти
JMP Short
Команда следующая за командой безусловного передачи управления должна иметь метку
M2: ----/----
M1: MOV AX, CX
К командам безусловной передачи относятся команды обращения к подпрограмме и возвращения из неё

Подпрограммы - процедуры, у которой тип дальности определяется параметром NEAR по умолчанию или FAR 
Процедура типа NEAR может быть вызвана только из того кодового сегмента, в котором содержится её полное определение. А процедура типа FAR может быть вызвана из любого кодового сегмента. Поэтому головной исходный модуль - основная программа оформляется как процедура типа FAR, поскольку к ней мы обращаемся из ОС, из отладчика, и если в ней используется подпрограмма, определенная в этом же кодовом сегменте, то все они будут типа NEAR. 
А если подпрограмм много, то им, возможно, уделяется отдельный кодовый сегмент, и все эти процедуры, реализующие подпрограмму будут типа FAR

Пример:
  extrn p2: far
  cseg segment...
  assume...
  p1 proc far
  --------
    call p2
    ret
  p1 endp
  cseg ends

  public p2
  cseg segment...
  assume ....
  p2 proc far
    ----
    ret
  p2 endp
  cseg1 ends

Команда обращения к подпрограмме CALL <имя>
Если команда обращается к внутренней процедуре типа NEAR, то в стеке сохраняется в качестве адреса возврата содержимое регистра указателя / счетчика команд IP / EIP
В этом регистре содержится адрес следующей за CALL команды
Если CALL обращается к внешней процедуре, то в стек записывается полный адрес точки возврата CS:EIP

Возврат из процедуры - тоже команда безусловной передачи управления и может иметь вид
RET [n]  ; возврат и из ближней и из дальней, но скорее всего медленней
RETN [n] ; из ближней
RETF [n] ; из дальней

А параметр если он есть определяет какое количество байтов удаляется из стека после возврата из процедуры.

Примеры прямого и косвенного перехода:

1) a dw L ; значением a является смещение для переменной L
  Возможны 2 варианта:
  jmp L ; прямой переход
  jmp a ; косвенный переход -> goto (a) = goto L

2) MOV DX, a; 
jmp DX ; косвенный переход

3)jmp z; 
------
z DW L
Итог - сообщение об ошибке

4)jmp word ptr z
-------------------
z DW L
-------------------
Итог - Нормально!

Команды условной передачи управления. Их оооооооочень много

Делят на 3 группы.
1) Которые идут после команд сравнения
2) После команд, отличных от команд сравнения, но реагирующих на значения флажков 
3) Команды, реагирующие на значение регистра CX

В общем виде команду условной передачи управления можно записать так:
Jx <метка>
x - одна, две или три буквы, определяющие условия

Метка указанная в поле операнда, должна стоять от команды не далее чем -128 +- 127 байт

JE M1 ; передача управления на команду с меткой M1, если ZF = 1
JNE M2 ; если ZF = 0
JC ; Если CF = 1
JNC ; если CF = 0

ADD AX, BX
JC M
Если в результате сложения CF = 1 (произошёл перенос), то передаем на команду с меткой M, иначе - на команду, следующую за JC

SUB AX, BX
JZ MET
Если результат вычитания будет 0, то ZF = 1 и управление передается на команду с меткой MET

Часто команды передачи управления после команды сравнения
  <метка> CMP OP1, OP2
  Результат - меняются флажки

Условие   Для знаковых  Для беззнаковых
>             JA              JG
=             JE              JE
<             JB              JL
>=             JAE              JGE
<=             JBE              JLE
<>             JNE              JNE

С помощью команды условной передачи можно организовать только команду короткой передачи. Если нужна дальняя, то нужно использовать команду условного перехода вместе с безусловным, изменив условие перехода.

Например, 
  if AX = BX goto m следует заменить на:

  if AX <> BX goto L
  Goto m
    где m - дальняя, L - ближняя

  На ассемблере:
    cmp AX, BX
    JNE L
    Jmp m
    L: -----------------
    --------------------
    --------------------
    m: -----------------

  С помощью команд Jx и JMP можно организовать цикл с предусловием:
  1) while x > 0 do S
    beg: cmp x, byte ptr 0
         jle fin
         ===========
         |    S    |
         ===========
         jmp beg
    fin:
  2) С постусловием:
    do S while x > 0;
      beg:
         ===========
         |    S    |
         ===========
         cmp x, byte ptr 0
         jg beg
      fin: 

|===========================================================|
|Специальные команды организации циклов и работы с массивами|
|===========================================================|
