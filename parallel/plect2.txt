...Пропустил 2 минуты лекции...
Граф операций и операндов 
Вершины - операции, дуги - наличие информационной зависимости
d(G) - диаметр, длина max пути

В качестве примера - вычисление площади прямоугольника по 2 точкам
         ______________ (x2, y2)
        |              |
        |              |
        |______________|
(x1, y1)

S = (x2 - x1)(y2 - y1)
           
           O x1y1 - x1y2 - y1x2 + y2x2
        ___/\___
      /         \
     /           \
   O x1y1 - x1y2   O y1x2 - y2x1
  /  \           /  \
 /    \         /    \
/      \       /      \
x1y1  x1y2   y2x2   x2y1
O      O      O    O
| \   / |     / \-/
| /\-/  |    / /  \
O/  O   O---/--    O
x1  y1  y2         x2

Получили расписание ^ те что не соединены дугами могут выполняться параллельно

Tp = min Tp(G)
      G

T_inf = min Tp паракомпьютер
        p>=1

Т1. Минимально возможное время выполнения алгоритма определяется длиной максимального
пути вычислительной схемы
T_inf(G) = d(G)

T2. T_inf(G) = log(2)(n), n - количество вершин ввода

(p - кол-во процессоров)
T3 для любого q = cp, o < c < 1 => Tp <= cT_q
При уменьшении числа процессоров время выполнения программы увеличивается пропорционально этой величине

T4 для любого кол-во исп. процессоров справедлива следующая верхняя оценка
времени выполнения параллельного алгоритма
для любого p => Tp < T1/p + T_inf
Д-во:

эта_t 
_____ - время выполнения операции
  p

Tp = sum(t=1..T_inf)(эта_t / p) < sum(t=1..T_inf)(эта_t / p + 1) = T1/p + T_inf

T5. p ~ T1/T_inf
p >= T1/T_inf => Tp <= 2T_inf
p <  T1/T_inf => T1/p < Tp <= 2T1 / p

Для оценки оптимальности методов введем основные показатели качества
1. Ускорение (speed-up)
Sp(n) = T1(n) / Tp(n)

2. Эффективность (efficiency)
Ep = T1(n) / (p * Tp(n))
Sp = p
Ep = 1
Sp > p  superlines (???)

3. Стоимость (cost)
Cp = p * Tp
Если алгоритм cost-optimal, то его стоимость пропорциональна времени выполнения 
наилучшего последовательного алгоритма

Пример моделей и анализа параллельн. алгоритмов - 
  задача нахождения частных сумм последовательности числовых значений

S = sum(i = 1..n)(xi)
  __,+--->+----->+      T1 = n-1
 /   |    |      |      
O    O    O      O
x1   x2   x3     x4
Считаем что n = 2^k - число входных данных
k = log(2)(n)

  Каскадная схема
      
      ___+__
     /      \
    /        \
   +          +
  / \        / \
 /   \      /   \
O     O    O     O
x1    x2   x3    x4

K_посл = n/2 + n/4 + ... + 1 = 2^k * (1/2 + 1/4 + ... + 1/(2^k)) = 2^k * (1 - 1/(2^k)) = n -1

K_парал = log(2)(n)
Sp = (n-1)/log(2)(n)
Ep = 1/p * Sp = 2/n * (n-1)/log(2)(n)    Ep -> 0 при n->inf
      ^ 
      |
     n/2                   ++
                    _______/\_______
                   /                \
                  /                  \
                 /                    \             Второй этап
               ++                      ++
             __/\__                  __/\__
            /      \                /      \
-----------/--------\--------------/--------\---
          /          \            /          \
         +           +           +           +
      +_/|        +_/|        +_/|        +_/|      Первый этап
   +_/|  |     +_/|  |     +_/|  |     +_/|  |
  /|  |  |    /|  |  |    /|  |  |    /|  |  |
O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O
x1 x2 x3 x4 x5 x6 x7 x8 x9 ...           x15 x16

Для первого этапа k = log(2)(n)
Процессоров: p1 = n/log(2)(n)

Для второго этапа p2 = p1/2 = n/2log(2)(n)

Для 1:
Tp = 2log(2)(n)
Sp = T1/Tp    = n-1 / 2log(2)(n)
Ep = 1/p * Sp = n-1 / 2n
Cp = p * Tp   = 2n

s1 = x1
s2 = x1 + x2
...
sn = x1 + x2 + ... + xn
Цель: параллельный алг. должен работать за log(2)(n)
Предположение: n = 2^k
Шаг1. Перед началом вычислений создается копия вектора x, записывается в S
Шаг2. На каждой итерации суммирования 1 <= i < log2n
Q_2^(i-1)+j <- S_j   ,  j = 1,2,...n-2^(i-1)

Освобождающиеся при сдвиге позиции обращаем в 0
Итерация алгоритма завершается суммированием вектора S с ветором U.
