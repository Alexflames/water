1.      Стиль программирования на языке Python.
Динамическая типизация
Функциональный, императивный, ООП. Код-стайл
4 пробела отступы, между функциями 2 строки, операторы пробелом
пробел после двоеточия и запятой
снейк-кейс

2.      Программа на  Python. Ввод-вывод данных. Основные алгоритмические конструкции. Последовательные действия.
Ввод-вывод с консоли и файлов
input() - строка ввода
print(строка вывода, заканчивается_каким_символом)

Следование, циклы (while, for), ветвление

ljust, rjust, zfill

f = open("file", 'mode')
f.read() / f.read(N symbols)
f.close()
for line in f:
	...
можно открыть бинарный и текстовые файлы, можно сделать разрешение и на запись и на ввод r+ w+

3.      Идентификаторы, комментарии, логические и физические строки.
Идентификаторы в Python это имена используемые для обозначения переменной, функции, класса, модуля или другого объекта. Идентификатор должен начинаться с буквы (от a до Z) или со знака подчеркивания (_), после которых может идти произвольное количество букв, знаков подчеркивания и чисел (от 0 до 9).

В Python недопустимо использование знаков препинания или специальных символов, таких как @, $ или % в качестве идентификаторов. Кроме того, Python чуствителен к регистру, то есть cat и Cat это два разных имени.

В Python существует следующая договоренность для названия идентификаторов:

Имена классов начинаются с большой буквы, все остальные идентификаторы - с маленькой.
Использования знака подчеркивания в качестве первого символа идентификатора означает, что данный идентификатор является частным (закрытым от использования вне класса).
Если идентификатор начинается и заканчивается двумя знаками подчеркивания (например, __init__ ) это означает, что он является специальным именем, определенным внутри языка.

Комментарии # перед строкой

Логические и физические понятно
2 физические могут быть 1 логической. 2 логические могут быть 1 физической если использована точка-запятая

4.      Операторы условия и выбора.

отсутствует свич-кейс
if-elif-else

Трехместный: A = Y if X else Z
and or not

5.      Операторы цикла: for, while.
...
do..while НЕТ в питоне

6.      Функция range. Операторы break, continue.
понятно

7.      Исключения. Обработка исключений при помощи блока try…except.
try:
<Блок, в котором перехватываются исключения>
[except [<Исключение 1> [as <Объект исключения>]]]:
<Блок, выполняемый при возникновении исключения>
[…]
[except [<Исключение N> [as <Объект исключения>]]]:
<Блок, выполняемый при возникновении исключения>
[else:
<Блок, выполняемый, если исключение не возникло>]
[finally:
<Блок, выполняемый в любом случае>]

raise EXCEPTION

8.      Встроенные типы данных. Целые и вещественные типы данных.
bool (True, False)
• int – целые числа, размер ограничен только объемом
памяти
• float – вещественные числа
• complex - комплексные числа
• str
• list, tuple, range, dict, set

9.      Типы комплексные числа, логический
imag, real, abs, pow
с логическими все понятно

10.  Встроенные функции для работы с разными типами данных.
 int(<объект>)
• float(<объект>)
• bin(<число>) – преобразует десятичное число в
бинарное
• oct(<число>) – преобразует десятичное число в
восьмеричное
• hex(<число>) – преобразует десятичное число в
шестнадцатеричное
• round(<число>[, <кол-во знаков после точки>]) –
округляет
• abs(<число>)
• pow(<число>, <степень> [, <делитель>]) – возводит в
степень. Если указан 3-й параметр, то возвращает
остаток отделения результата на третий параметр
• max(<список чисел через запятую>)
• min(<список чисел через запятую>)
• sum(<последовательность>[,
<начальное значение>])
• divmod(x, y) – возвращает кортеж из двух значений
(x//y, x%y)

11.  Строки, работа со строками, срезы
Неизменяемые
.split()
str()

len(s)
x in s
1, если x содержится в последовательности s, в противном случае - 0.
x not in s
0, если x не содержится в последовательности s, в противном случае - 1.
s + t
Объединение последовательностей s и t.
s * n
n * s
n копий последовательности s, объединенных вместе.
Отрицательные n приравниваются к нулю
s += t то же самое что и s = s + t
s *= t то же самое что и s = s * t
s[i]
i-й символ последовательности s
s[ [i]:[j] ]
срез последовательности s, который состоит из всех k-х элементов, i<=k<j

Методы find и rfind

s.startswith(<шаблон>) - начинается ли строка s с указанного шалона;
s.endswith(<шаблон>) - заканчивается ли строка шаблоном.

s.isdigit() - состоит ли строка из цифр;
s.isapha() - состоит ли строка из букв;
s.isalnum() - состоит ли строка из цифр и букв;
s.islower() - состоит ли строка из букв в нижнем регистре;
s.isupper() - состоит ли строка из букв в верхнем регистре;
s.isspace() - состоит ли строка из пробельных символов;
s.istitle() - начинаются ли слова в строке с заглавной буквы.
Некоторые методы для быcтрого изменения строки
s.lstrip() - удаляет пробельные символы в начале строки;
s.rstrip() - удаляет пробельные символы в конце строки;
s.strip() - удаляет пробельные символы в начале и конце строки;
s.zfill(ширина) - добавляет нули слева строки до достижения нужной
ширины;
s.ljust(ширина, символ) - добавляет символ в конце строки до нужной
ширины;
s.rjust(ширина, символ) - добавляет символ в начале строки до нужной
ширины.
bool(s) – возвращает True, если строка не пустая

12.  Списки. Создание списков. Методы join и split.
[]
.split()
• s = a + b
• x in s: x not in s
• s * n
• s[n], s[start:stop:step]
• len(s)
• max(s) – максимальный элемент списка
• min(s) – минимальный элемент списка
• sum(s) – сумма элементов списка
• s.index(x)
• s.count(x)
• s.append(x)
• s.extend(s1)
• del s[i]; del s[start:stop:step]; s.clear()
• s_new = s.copy()
• s.insert(n, x)
• x = s.pop(n) – получить n-й элемент списка, удалив его
• s.remove(x) удалить из s первое вхождение x, в случае
отсутствия x в s – ошибка
• s.reverse()
• s.sort() – отсортировать; s.sort(reverse=True) –
отсортировать по убыванию
• bool(s) – возвращает True, если список не пустой
• s = list(string1) – преобразует строку string1 в список
Для получения информации о списке методов любого
объекта в Python существует специальная функция dir.
print(dir([]))
help([].insert) – помощь по конкретному методу

map, filter, zip, reduce

13.  Кортежи
Как списки только неизменяемые
Можно применить все неизменяющие операции как и к списку

14.  Словари. Создание словарей. Методы для работы со словарями.
1.
d = {}
d = {'dict': 1,
'dictionary': 2}
2. С помощью функции dict
d = dict(short='dict', long='dictionary')
#d={'short': 'dict', 'long': 'dictionary'}
d = dict([(1, 1), (2, 4)])
#d={1: 1, 2: 4}
3. C помощью метода fromkeys
d = dict.fromkeys(['a', 'b'])
#d={'a': None, 'b': None}
d = dict.fromkeys(['a', 'b'], 100)
#d={'a': 100, 'b': 100}
4. C помощью генераторов словарей, которые очень
похожи на генераторы списков
d = {a: a ** 2 for a in range(7)}
# d = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}

dict.clear() - очищает словарь.
dict.copy() - возвращает копию словаря.
dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением
value (по умолчанию None).
dict.get(key[, default]) - возвращает значение ключа, но если его нет, не
бросает исключение, а возвращает default (по умолчанию None).
dict.items() - возвращает пары (ключ, значение).
dict.keys() - возвращает ключи в словаре.
dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа
нет, возвращает default (по умолчанию бросает исключение).
dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь
пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет,
не бросает исключение, а создает ключ с значением default (по умолчанию
None).
dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из
other. Существующие ключи перезаписываются. Возвращает None (не новый
словарь!).
dict.values() - возвращает значения в словаре

15.  Множества. Методы работы с множествами.
Множества – это неупорядоченные наборы простых
объектов. Они необходимы тогда, когда присутствие объекта в
наборе важнее порядка или того, сколько раз данный объект там
встречается.

set.isdisjoint(other) - истина, если set и other не имеют общих
элементов.
set == other - все элементы set принадлежат other, все элементы
other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат
other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких
множеств set, other, ...
set.intersection(other, ...) или set & other & ... - пересечение
множеств.
set.difference(other, ...) или set - other - ... - множество из всех
элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из
элементов, встречающихся в одном множестве, но не встречающиеся в
обоих.
set.copy() - копия множества.
set.update(other, ...); set |= other | ... - объединение.
set.intersection_update(other, ...); set &= other & ... -
пересечение.
set.difference_update(other, ...); set -= other | ... - вычитание.
set.symmetric_difference_update(other); set ^= other -
множество из элементов, встречающихся в одном множестве, но не
встречающиеся в обоих.
set.add(elem) - добавляет элемент в множество.
set.remove(elem) - удаляет элемент из множества. KeyError,
если такого элемента не существует.
set.discard(elem) - удаляет элемент, если он находится в
множестве.
set.pop() - удаляет первый элемент из множества. Так как
множества не упорядочены, нельзя точно сказать, какой элемент
будет первым.
set.clear() - очистка множества.

16.  Понятие функционального программирования. Принцип построения функциональных программ.
Функции
Локальные переменные
Глобальные переменные
Нелокальная область видимости
Значения параметров по умолчанию
Ключевые аргументы
Переменное число параметров
	Когда мы объявляем параметр со звёздочкой (например, *param), все
	позиционные аргументы начиная с этой позиции и до конца будут собраны в
	кортеж под именем param.
	Аналогично, когда мы объявляем параметры с двумя звёздочками
	(**param), все ключевые аргументы начиная с этой позиции и до конца будут
	собраны в словарь под именем param.
Оператор return
Рекурсия
Функции, определенные lambda-выражением

17.  Функция: определение и вызов. Рекурсия.
см. выше

18.  Глобальные и локальные переменные. Нелокальная область видимости.
см. выше

19.  Параметры функций: параметры по умолчанию, ключевые аргументы, переменное число параметров.
см. выше

20.  Функции, определенные lambda-выражением.
см. выше

21.  Понятие модуля. Модули в Python. Подключение модулей.
Формат команды import
import module_1[, module_2[,... module_
from module import ... (*)

22.  Обзор стандартной библиотеки.  Список всех подключенных модулей. Помощь по модулю
help("modules")
help("MODULE_NAME")

23.  Модуль math.

Модуль math – один из наиважнейших в Python. Этот модуль предоставляет обширный функционал для работы с числами.

math.ceil(X) – округление до ближайшего большего числа.

math.fabs(X) - модуль X.

math.factorial(X) - факториал числа X.

math.floor(X) - округление вниз.

math.fmod(X, Y) - остаток от деления X на Y.

math.ldexp(X, I) - X * 2i. Функция, обратная функции math.frexp().

math.fsum(последовательность) - сумма всех членов последовательности. Эквивалент встроенной функции sum(), но math.fsum() более точна для чисел с плавающей точкой.

math.isfinite(X) - является ли X числом.

math.isinf(X) - является ли X бесконечностью.

math.isnan(X) - является ли X NaN (Not a Number - не число).

math.modf(X) - возвращает дробную и целую часть числа X. Оба числа имеют тот же знак, что и X.

math.trunc(X) - усекает значение X до целого.

math.exp(X) - eX.

math.expm1(X) - eX - 1. При X → 0 точнее, чем math.exp(X)-1.

math.log(X, [base]) - логарифм X по основанию base. Если base не указан, вычисляется натуральный логарифм.

math.log1p(X) - натуральный логарифм (1 + X). При X → 0 точнее, чем math.log(1+X).

math.log10(X) - логарифм X по основанию 10.

math.log2(X) - логарифм X по основанию 2. Новое в Python 3.3.

math.pow(X, Y) - XY.

math.sqrt(X) - квадратный корень из X.

math.acos(X) - арккосинус X. В радианах.

math.asin(X) - арксинус X. В радианах.

math.atan(X) - арктангенс X. В радианах.

math.atan2(Y, X) - арктангенс Y/X. В радианах. С учетом четверти, в которой находится точка (X, Y).

math.cos(X) - косинус X (X указывается в радианах).

math.sin(X) - синус X (X указывается в радианах).

math.tan(X) - тангенс X (X указывается в радианах).

math.hypot(X, Y) - вычисляет гипотенузу треугольника с катетами X и Y (math.sqrt(x * x + y * y)).

math.degrees(X) - конвертирует радианы в градусы.

math.radians(X) - конвертирует градусы в радианы.

math.cosh(X) - вычисляет гиперболический косинус.

math.sinh(X) - вычисляет гиперболический синус.

math.tanh(X) - вычисляет гиперболический тангенс.

math.acosh(X) - вычисляет обратный гиперболический косинус.

math.asinh(X) - вычисляет обратный гиперболический синус.

math.atanh(X) - вычисляет обратный гиперболический тангенс.

math.pi - pi = 3,1415926...
math.e - e = 2,718281...

24.  Создание своего модуля и пакета модулей.
__init__.py - для модуля внутри пакета
setup.py
README.txt

25.  Работа с файлами в языке Python. Методы объектов-файлов. Модуль pickle.
>>> f=open('file.txt', 'rb+')
>>> f.write('0123456789abcdef')
>>> f.seek(5) # Перейти к 5му байту в файле
>>> f.read(1)
'5'
>>> f.seek(-3, 2) # Перейти к 3му байту с конца
>>> f.read(1)
file.closed	Возвращает True если файл был закрыт.
file.mode	Возвращает режим доступа, с которым был открыт файл.
file.name	Возвращает имя файла.
file.softspace	Возвращает False если при выводе содержимого файла следует отдельно добавлять пробел.
file.close()
file.tell() - позиция указателя

Модуль pickle реализует мощный алгоритм сериализации и десериализации объектов Python. "Pickling" - процесс преобразования объекта Python в поток байтов, а "unpickling" - обратная операция, в результате которой поток байтов преобразуется обратно в Python-объект. Так как поток байтов легко можно записать в файл, модуль pickle широко применяется для сохранения и загрузки сложных объектов в Python.

>>> import pickle
>>> data = {
...     'a': [1, 2.0, 3, 4+6j],
...     'b': ("character string", b"byte string"),
...     'c': {None, True, False}
... }
>>>
>>> with open('data.pickle', 'wb') as f:
...     pickle.dump(data, f)
...
>>> with open('data.pickle', 'rb') as f:
...     data_new = pickle.load(f)
...
>>> print(data_new)
{'c': {False, True, None}, 'a': [1, 2.0, 3, (4+6j)], 'b': ('character string', b'byte string')}

26.  Основные понятия объектно-ориентированного программирования. Определение класса. Конструкторы и деструкторы.
Абстракция (интерфейсы)
Инкапсуляция (private)
Полиморфизм (причем в Питоне не обязательно чтобы они были в одной иерархии, просто одинаковое имя метода)
Наследование

class название_класса [(класс1, …, классN)]:
[“”” Строка документации “”””]

Все атрибуты класса являются открытыми (public)
Атрибуты можно создавать динамически после создания
класса 

class MyClass:
	x = 10 #атрибут объекта класса
	def __init__(self):
		self.y = 20 #атрибут экземпляра класса

Методы __init__() и __del__()

Нужно помнить о `self`
def start_engine(self):

@staticmethod

В Python все члены класса (включая данные) являются
публичными (public), а все методы – виртуальными (virtual).

Исключение: переменная начинающаяся с двух нижних подчеркиваний (__privatevar)
• getattr (объект, атрибут[, значение по умолчанию]) –
• setattr (объект, атрибут, значение по умолчанию) -
• delattr (объект, атрибут) – удаляет указанный атрибут
• hasattr (объект, атрибут) – проверяет наличие атрибута

27.  Отношения между классами. Наследование.
class SchoolMember:
class Teacher(SchoolMember):
class Student(SchoolMember):
	def __init__(self, name, age, marks):
		super().__init__(name, age)

class Class4(Class2, Class3):
	# Наследуем func2() из класса Class3,
	# а не из класса Class2
	func2 = Class3.func2
	def func4(self):
		print("Метод func4() класса Class4")

@abstractmethod

28.  Метаклассы.
вот будет мемно если выпадет этот вопрос :) 

29.  Обзор графических библиотек. Библиотека Tkinter.


30.  Обзор виджетов и их свойств.
	Tk()
• Toplevel (окно верхнего уровня)
• Frame (рамка)
• Label
• Entry
• Text
• Radiobutton (переключатели)
• Checkbutton (флажки)
• Listbox (списки)
• Scale (шкала)
• Scrollbar

31.  Создание и конфигурирование виджета.
либо при создании либо с помощью .configure(аттрибутнейм, значение)

32.  Менеджеры расположения.
pack()
При использовании этого упаковщика с помощью свойства side нужно
указать к какой стороне родительского виджета он должен примыкать. Как
правило этот упаковщик используют для размещения виджетов друг за
другом (слева направо или сверху вниз).

grid()
Этот упаковщик представляет собой таблицу с ячейками, в которые
помещаются виджеты.

place()
представляет собой простой упаковщик, позволяющий размещать виджет в
фиксированном месте с фиксированным размером. Также он позволяет
указывать координаты размещения в относительных единицах для
реализации "резинового" размещения. При использовании этого
упаковщика, нам необходимо указывать координаты каждого виджета.

33.  Изображения в Tkinter.
Создать Canvas
self.image_obj = canv.create_image(0, 0)
self.img = PhotoImage(file=filename)
self.canv.itemconfigure(self.image_obj, image=self.img, anchor="w")

34.  Создание приложения с использованием Tkinter.
Создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем создаем фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги фиксим баги готово