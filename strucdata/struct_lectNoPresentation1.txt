Нахождение сложности рекурсивных алгоритмов
1) Решение рекуррентных соотношений (оценка сверху, не всегда решение, нельзя узнать затраты по памяти)
  а) Метод мат.индукции
  б) Подстановки (сводим к t(n) -> t(n0)) n0 известно - константа
2) Графовый (?)

|===============================|
|Классы рекуррентных соотношений|  
|===============================|
1) "Разделяй и властвуй"
Характерно изменение параметра рекурсии n/k , k > 1
n = 0, n = k^m, t(1)

I
        { n , 0 <= n <= n0
t (n) = { 
        { A(n)t(n / k) + B(n), n > n0 >= 0

II
        { C , 0 <= n <= n0
t (n) = { 
        { A(n)t(n / k) + B(n), n > n0 >= 0
Здесь параметр рекурсии изменяется линейно.
Для решения такого уравнения надо определить вид функций A(n) и B(n)

A(n) = a - число задач, порождаемых рекурсивной ветвью алгоритма
B(n) = bn^т - трудоемкость рекурсивного перехода

Теорема. Решение первого класса рекурсивных алгоритмов вида:
I
        { c , n = 1                       a > 0, k > 1, b >= 0,
t (n) = {                                 c >= 0, т >= 0, 
        { at(n / k) + Bn^т, n > 1         n = k^m

Тогда решение в виде

          { a^m * c + b*k^mт * m, a = k^т                       
t (k^m) = {                                 
          { a^m * c + b*k^mт *  (a / k^т)^m - 1, 
                               ----------------- , a != k^т
                                 (a / k^т) - 1

T(n) <= a {at(n/k^2) + b*n^т/k^т} + bk^т = a^2 * t(n/k^2) + ab * n^т / k^т + bn^т =
= a^2 {at(n/k^3) + bn^т } + ab * n^т / k^т + bn^т = a^3 * t(n/k^3) + a^2*b*n^т/k^(2t) +
+ ab*n^т/k^т + bn^t

a^i*t(n/k^i) + sum(from j = 0 to i - 1) a^j*b*n^т/k^(j*т)

a^m*c + b*n^т * sum(from j = 0 to m - 1) a^j / k^(jt) 
--------- при a = k^t T(k^m) <= a^m * c + bk^(mt) * m

Ну и доказано

Следствие 1
1. a = k^т, m = log_k_т
t(n) <= O(n^т * log_k_n) ------ a = k^т, т = 1
2. a > k^т
t(n) <= O(n^(log_k_a))
3. a < k^т
t(n) <= O(n^т)
4. b = 0, c > 0
t(n) <= O(a^(log_k_n)) = O(n^(log_k_a)) 

Лекция №2
Если t(n) = ( c, 0 <= n <= k - 1
            { 
            ( at(n-k) + bn^т, n >= k
--------
|n = mk|
--------

То верны следующие неравенства
c + bn^(т-1) <= t(n) <= c + b/k * n^(т+1)
a^(n/k)*c + bk^т (a^(n/k) - 1)/(a - 1) <= t(n) <= a^(n/k) * c + bn^т(a) * (a^(n/k) - 1)/(a - 1) , a =/= 1

Док-во:
f(m) = t(km)
t(km - k) = t(k(m - 1)) = f(m - 1)

             ( c
(**) t(km) = {
             ( at(km - k) + bk^т*m^т , m > 0

             ( .......
(  ) f(n) =  {
             ( .......

f(m) = a{a f(m - 2) + bk^т(m - 1)^т} + bk^т*m^т = 
a^2 * f(m - 2) + abk^т*(m-1)^т + bk^т * m^т =
a^2{a f(m - 3) + bk^т(m - 2)^т} + abk^т(m-1)^т + bk^т*m^т =
a^3 * f(m - 3) + a^2*bk^т*(m - 2)^т + abk^т(m-1)^т + bk^т*m^т (и так далее)

=> a^i * f(m - 1) + sum(from j = 0 to i - 1)(a^j * bk^т * (m - j)^т)

При m = 0, S(a, т, 0) = 0
При m > 0, S(a, т, m) = sum(from i = 1 to m)(a^(m - 1) * i^т)
При т = 0  S(a, 0, m) = sum(from i = 1 to m)(a^(m - 1) * i^т) =
sum(from i = 1 to m)(1^(m - 1) * i^0) = m, a = 1
sum(from i = 1 to m)(a^(m - 1) * i^0) = (a^m - 1) / (a - 1), a =/= 1

a^m * c + bk^т = sum(from j = 0 to m-1)(aj * (m - j)^т)
                                      ( c + bm, a = 1
f(m) = a^m * c + bk^0 * S(a, m, 0) =  {
                                      ( a^m * c + b* (a^m - 1) / (a - 1), a =/= 1

Найдем верхнюю и нижнюю оценку при т > 0, m > 0 и a = 1 и a =/= 1

sum(from i = 1 to m)(a^(m - 1) * i^т)

a^(m - i) <= a^(m - т) * i^т <= a^(m - т) * m^т

sum(from i = 1 to m)(a^(m - i)) <= S(a, m, т) <= sum(from i = 1 to m)(a^(m - i) * m^т)

a = 1 S0 = m
S1 = m^(т + 1)

c + bk^(т)*m <= f(m) <= c + bk^т*m(т+1)  f(m) = a^m * c + bk^т * S(1, m, т)

a =/= 1, S0 = (a^m - 1)/(a - 1)
         S1 = m^т * (a^m - 1) / (a - 1)

.............
Д-д-доказано!

Следствие
                 ( c + b/k * n, a = 1
1. т = 0, t(m) = {
                 ( a^(n / k) * c + b * (a^(n/k) - 1) / (a - 1), a =/= 1

                                             ( O(n), a = 1, b > 0
2. т = 0, для любого с > 0 n->+inf    t(n) = {
                                             ( O(a^(n/k)) a =/= 1, b > 0

3. т >= 0, a = 1, c >= 0, b > 0, n -> +inf
t(n) = O(n^(т+1))

4. a > 1, c >= 0, b > 0, т > 0  t(n) = O(a^(n-k))

Анализ рекурсивной эффективности рекурсивных алгоритмов 
  методом подсчета вершин дерева рекурсии

  Строится полное дерево рекурсии узлами которого являются наборы фактических 
  параметров при всех вызовах функции

  При вызове функции в стек помещается адрес возврата, состояние необходимых регистров
  процессора, состояние локальных ячеек вызывающей функции

  p - количество передаваемых факт. параметров
  r - сохраняемых в стеке регистров
  k - количество возвращаемых по адресной ссылке значений
  l - количество возвращаемых (что-то)

  Анализ дерева рекурсии.
    Характеристики: 
      Глубина рекурсивных вызовов - ...

      Объем рекурсии - количество вершин

      R(N) - общее число вершин дерева рекурсии
      R_v(N) - объем рекурсии без листьев
      R_L(N) - количество листьев дерева рекурсии
      H_R(N) - глубина рекурсии

      R(N) = R_V(N) + R_L(N), H_R(N) <= R_V(N) + R_L(N)

      Требуемый объем памяяти - максимальная глубина листьев

      V(N) = H_R(N) * (p + r + k + l + 1) * u_B - оценка требуемой памяти
      u_B - длина байтового


    Для построения ресурсных функций рекурсивных алгоритмов необходимо учесть ряд
    особенностей рекурсивной реализации, а именно:
      - ресурсные затраты обслуживания рекурсии
      - ресурсные затраты в листьях дерева рекурсии

    Трудоемкость F - во всех вершинах

    .....

    Зная количество листьев порожденного дерева рекурсии, можно определить 
      F_CL(N) = F_CL(1) * R_L(N)

      ...

      Трудоемкость продуктивных вычислений различна во внутренних вершинах дерева:
        F_A(N) = R(N) * F_(c/b) + F_cl(1) * R_L*(N) = sum(....)(...)

      В частном случае F_A(N) = .......

  Этапы анализа трудоемкости рекурсивного алгоритма 