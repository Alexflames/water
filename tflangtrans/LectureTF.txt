	Лексический анализ
	|			  |
лексема			токен

Лексический анализ - процесс, в котором программа получает текст а на выход дает лексемы вида <тип лексемы, токен>
Допустим есть тип лексемы: 
KW (key word): if, do, else, while, for
ID (идентификатор): все слова из символов и подчеркиваний, не являющ. ключевыми словами 
AS: :=
OP: +, -, *, /, ==
INT: 
REAL: 

Пусть прогр.: a12 := a2 + 5 * b3 / 0.37
\_____________________________________/
<ID, a12>
<AS, :=>
<ID,  a2>
<OP, +>				<------ результат лексического анализа
<INT, 5> 					18 символов, поделены на 9 токенов
<OP, *> 
<ID, b3>
<OP, />
<REAL, 0,37>

В наше время есть проги которые генерируют лексический анализатор
На вход язык, на выход лекс. анализатор
Пример такой программы, популярной: lex, а также есть flex и clex

Основной инструмент лексического анализа - конечные автоматы
Q - входные
S - мн-во начальн
(Q, E, d, S)

Практика 16.09
Допустимые слова на основе входных-выходных состояний; в недетерменированных тоже

Задача №1:
str = a0a1a2a3...........a(l)a(l+1)...........an
Описать функцию
maxString(A-автомат, str, l - номер позиции(обрабатываем строку с символа эль)) => <True/False, m>
Автомату подается строка, и начиная с l символа подает символы в автомат, и нужно найти m = max(len(substr)) такой что
substr - строка, допустимый вход в автомат

тело ф-ии

Flag = False
m = 0, i = l
curState = q0  // если недетерминированный, то множество
if curState конечно then Flag=True 
while i <= n:
  curState = A.T[curState][str[i]] // если undeterm. то нужно обновить множество, пересечение наверное
  if curState конечно then Flag=True // при undeterm. если в множестве хотя б одно есть
  m = i - l + 1
  i++
return (Flag, m)

Будем применять эту функцию для нахождения слова в строку. Напр. дан текст, а нужно найти все
вещественные числа в тексте.

Задание №2
На вход дается текстовый файл, считать файл как единую строку и прогнать через maxString
Найти все вещественные числа в файле и вывести в отдельный файл

  Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск | Поиск

  Берем k = 0, пытаемся найти первое вхождение с помощью maxString
  while k <= n :
    res, m = maxString(A, str, k)
    if res && m != 0:
      k = k + m
    else:
      k = k + 1

Примечание: числа вещественные со знаком
25, +25, -25,
25.5 +25.5 -25.5
+25. -25. 25.
+.5 -.5 .7
e E 25e5 2.e18 25e+25
.8e7 .7e-8 +.7E+5

Прим2. A = (Q, E, delta, S, F)
Определяем 1)нач. сост, 2)сигналы, 3)переходы, 4)конечн. состояния 5) 